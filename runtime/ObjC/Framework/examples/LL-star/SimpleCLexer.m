/** \file
 *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
 *
 *     -  From the grammar source file : SimpleC.g
 *     -                            On : 2011-05-06 13:53:12
 *     -                 for the lexer : SimpleCLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// $ANTLR ${project.version} ${buildNumber} SimpleC.g 2011-05-06 13:53:12


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "SimpleCLexer.h"
/* ----------------------------------------- */


/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */

/** As per Terence: No returns for lexer rules! */
@implementation SimpleCLexer // line 330

+ (void) initialize
{
    [ANTLRBaseRecognizer setGrammarFileName:@"SimpleC.g"];
}

+ (NSString *) tokenNameForType:(NSInteger)aTokenType
{
    return [[self getTokenNames] objectAtIndex:aTokenType];
}

+ (SimpleCLexer *)newSimpleCLexerWithCharStream:(id<ANTLRCharStream>)anInput
{
    return [[SimpleCLexer alloc] initWithCharStream:anInput];
}

- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
{
    self = [super initWithCharStream:anInput State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:18+1] retain]];
    if ( self != nil ) {
    }
    return self;
}

- (void) dealloc
{
    [super dealloc];
}

/* ObjC Start of actions.lexer.methods */
/* ObjC end of actions.lexer.methods */
/* ObjC start methods() */
/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "T__7"
- (void) mT__7
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__7;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:7:6: ( '(' ) // ruleBlockSingleAlt
        // SimpleC.g:7:8: '(' // alt
        {
        [self matchChar:'(']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__7" */

// $ANTLR start "T__8"
- (void) mT__8
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__8;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:8:6: ( ')' ) // ruleBlockSingleAlt
        // SimpleC.g:8:8: ')' // alt
        {
        [self matchChar:')']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__8" */

// $ANTLR start "T__9"
- (void) mT__9
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__9;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:9:6: ( '+' ) // ruleBlockSingleAlt
        // SimpleC.g:9:8: '+' // alt
        {
        [self matchChar:'+']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__9" */

// $ANTLR start "T__10"
- (void) mT__10
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__10;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:10:7: ( ',' ) // ruleBlockSingleAlt
        // SimpleC.g:10:9: ',' // alt
        {
        [self matchChar:',']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__10" */

// $ANTLR start "T__11"
- (void) mT__11
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__11;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:11:7: ( ';' ) // ruleBlockSingleAlt
        // SimpleC.g:11:9: ';' // alt
        {
        [self matchChar:';']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__11" */

// $ANTLR start "T__12"
- (void) mT__12
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__12;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:12:7: ( '<' ) // ruleBlockSingleAlt
        // SimpleC.g:12:9: '<' // alt
        {
        [self matchChar:'<']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__12" */

// $ANTLR start "T__13"
- (void) mT__13
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__13;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:13:7: ( '=' ) // ruleBlockSingleAlt
        // SimpleC.g:13:9: '=' // alt
        {
        [self matchChar:'=']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__13" */

// $ANTLR start "T__14"
- (void) mT__14
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__14;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:14:7: ( '==' ) // ruleBlockSingleAlt
        // SimpleC.g:14:9: '==' // alt
        {
        [self matchString:@"=="]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__14" */

// $ANTLR start "T__15"
- (void) mT__15
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__15;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:15:7: ( 'char' ) // ruleBlockSingleAlt
        // SimpleC.g:15:9: 'char' // alt
        {
        [self matchString:@"char"]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__15" */

// $ANTLR start "T__16"
- (void) mT__16
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__16;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:16:7: ( 'for' ) // ruleBlockSingleAlt
        // SimpleC.g:16:9: 'for' // alt
        {
        [self matchString:@"for"]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__16" */

// $ANTLR start "T__17"
- (void) mT__17
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__17;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:17:7: ( 'int' ) // ruleBlockSingleAlt
        // SimpleC.g:17:9: 'int' // alt
        {
        [self matchString:@"int"]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__17" */

// $ANTLR start "T__18"
- (void) mT__18
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__18;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:18:7: ( 'void' ) // ruleBlockSingleAlt
        // SimpleC.g:18:9: 'void' // alt
        {
        [self matchString:@"void"]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__18" */

// $ANTLR start "T__19"
- (void) mT__19
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__19;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:19:7: ( '{' ) // ruleBlockSingleAlt
        // SimpleC.g:19:9: '{' // alt
        {
        [self matchChar:'{']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__19" */

// $ANTLR start "T__20"
- (void) mT__20
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__20;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:20:7: ( '}' ) // ruleBlockSingleAlt
        // SimpleC.g:20:9: '}' // alt
        {
        [self matchChar:'}']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__20" */

// $ANTLR start "ID"
- (void) mID
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = ID;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:94:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* ) // ruleBlockSingleAlt
        // SimpleC.g:94:9: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* // alt
        {
        if ((([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
            [input consume];
        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
            [self recover:mse];
            @throw mse;
        }


        do {
            NSInteger alt1=2;
            NSInteger LA1_0 = [input LA:1];
            if ( ((LA1_0 >= '0' && LA1_0 <= '9')||(LA1_0 >= 'A' && LA1_0 <= 'Z')||LA1_0=='_'||(LA1_0 >= 'a' && LA1_0 <= 'z')) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 : ;
                    // SimpleC.g: // alt
                    {
                    if ((([input LA:1] >= '0') && ([input LA:1] <= '9'))||(([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
                        [input consume];
                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }


                    }
                    break;

                default :
                    goto loop1;
            }
        } while (YES);
        loop1: ;


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "ID" */

// $ANTLR start "INT"
- (void) mINT
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = INT;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:97:5: ( ( '0' .. '9' )+ ) // ruleBlockSingleAlt
        // SimpleC.g:97:7: ( '0' .. '9' )+ // alt
        {
        // SimpleC.g:97:7: ( '0' .. '9' )+ // positiveClosureBlock
        NSInteger cnt2 = 0;
        do {
            NSInteger alt2 = 2;
            NSInteger LA2_0 = [input LA:1];
            if ( ((LA2_0 >= '0' && LA2_0 <= '9')) ) {
                alt2=1;
            }


            switch (alt2) {
                case 1 : ;
                    // SimpleC.g: // alt
                    {
                    if ((([input LA:1] >= '0') && ([input LA:1] <= '9'))) {
                        [input consume];
                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }


                    }
                    break;

                default :
                    if ( cnt2 >= 1 )
                        goto loop2;
                    ANTLREarlyExitException *eee =
                        [ANTLREarlyExitException newException:input decisionNumber:2];
                    @throw eee;
            }
            cnt2++;
        } while (YES);
        loop2: ;


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "INT" */

// $ANTLR start "WS"
- (void) mWS
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = WS;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // SimpleC.g:100:5: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ ) // ruleBlockSingleAlt
        // SimpleC.g:100:9: ( ' ' | '\\t' | '\\r' | '\\n' )+ // alt
        {
        // SimpleC.g:100:9: ( ' ' | '\\t' | '\\r' | '\\n' )+ // positiveClosureBlock
        NSInteger cnt3 = 0;
        do {
            NSInteger alt3 = 2;
            NSInteger LA3_0 = [input LA:1];
            if ( ((LA3_0 >= '\t' && LA3_0 <= '\n')||LA3_0=='\r'||LA3_0==' ') ) {
                alt3=1;
            }


            switch (alt3) {
                case 1 : ;
                    // SimpleC.g: // alt
                    {
                    if ((([input LA:1] >= '\t') && ([input LA:1] <= '\n'))||[input LA:1] == '\r'||[input LA:1] == ' ') {
                        [input consume];
                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }


                    }
                    break;

                default :
                    if ( cnt3 >= 1 )
                        goto loop3;
                    ANTLREarlyExitException *eee =
                        [ANTLREarlyExitException newException:input decisionNumber:3];
                    @throw eee;
            }
            cnt3++;
        } while (YES);
        loop3: ;


         _channel=HIDDEN; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* my stuff */
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "WS" */

- (void) mTokens
{
    // SimpleC.g:1:8: ( T__7 | T__8 | T__9 | T__10 | T__11 | T__12 | T__13 | T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | ID | INT | WS ) //ruleblock
    NSInteger alt4=17;
    unichar charLA4 = [input LA:1];
    switch (charLA4) {
        case '(': ;
            {
            alt4=1;
            }
            break;
        case ')': ;
            {
            alt4=2;
            }
            break;
        case '+': ;
            {
            alt4=3;
            }
            break;
        case ',': ;
            {
            alt4=4;
            }
            break;
        case ';': ;
            {
            alt4=5;
            }
            break;
        case '<': ;
            {
            alt4=6;
            }
            break;
        case '=': ;
            {
            NSInteger LA4_7 = [input LA:2];

            if ( (LA4_7=='=') ) {
                alt4=8;
            }
            else {
                alt4 = 7;
            }
            }
            break;
        case 'c': ;
            {
            NSInteger LA4_8 = [input LA:2];

            if ( (LA4_8=='h') ) {
                NSInteger LA4_19 = [input LA:3];

                if ( (LA4_19=='a') ) {
                    NSInteger LA4_23 = [input LA:4];

                    if ( (LA4_23=='r') ) {
                        NSInteger LA4_27 = [input LA:5];

                        if ( ((LA4_27 >= '0' && LA4_27 <= '9')||(LA4_27 >= 'A' && LA4_27 <= 'Z')||LA4_27=='_'||(LA4_27 >= 'a' && LA4_27 <= 'z')) ) {
                            alt4=15;
                        }
                        else {
                            alt4 = 9;
                        }
                    }
                    else {
                        alt4 = 15;
                    }
                }
                else {
                    alt4 = 15;
                }
            }
            else {
                alt4 = 15;
            }
            }
            break;
        case 'f': ;
            {
            NSInteger LA4_9 = [input LA:2];

            if ( (LA4_9=='o') ) {
                NSInteger LA4_20 = [input LA:3];

                if ( (LA4_20=='r') ) {
                    NSInteger LA4_24 = [input LA:4];

                    if ( ((LA4_24 >= '0' && LA4_24 <= '9')||(LA4_24 >= 'A' && LA4_24 <= 'Z')||LA4_24=='_'||(LA4_24 >= 'a' && LA4_24 <= 'z')) ) {
                        alt4=15;
                    }
                    else {
                        alt4 = 10;
                    }
                }
                else {
                    alt4 = 15;
                }
            }
            else {
                alt4 = 15;
            }
            }
            break;
        case 'i': ;
            {
            NSInteger LA4_10 = [input LA:2];

            if ( (LA4_10=='n') ) {
                NSInteger LA4_21 = [input LA:3];

                if ( (LA4_21=='t') ) {
                    NSInteger LA4_25 = [input LA:4];

                    if ( ((LA4_25 >= '0' && LA4_25 <= '9')||(LA4_25 >= 'A' && LA4_25 <= 'Z')||LA4_25=='_'||(LA4_25 >= 'a' && LA4_25 <= 'z')) ) {
                        alt4=15;
                    }
                    else {
                        alt4 = 11;
                    }
                }
                else {
                    alt4 = 15;
                }
            }
            else {
                alt4 = 15;
            }
            }
            break;
        case 'v': ;
            {
            NSInteger LA4_11 = [input LA:2];

            if ( (LA4_11=='o') ) {
                NSInteger LA4_22 = [input LA:3];

                if ( (LA4_22=='i') ) {
                    NSInteger LA4_26 = [input LA:4];

                    if ( (LA4_26=='d') ) {
                        NSInteger LA4_30 = [input LA:5];

                        if ( ((LA4_30 >= '0' && LA4_30 <= '9')||(LA4_30 >= 'A' && LA4_30 <= 'Z')||LA4_30=='_'||(LA4_30 >= 'a' && LA4_30 <= 'z')) ) {
                            alt4=15;
                        }
                        else {
                            alt4 = 12;
                        }
                    }
                    else {
                        alt4 = 15;
                    }
                }
                else {
                    alt4 = 15;
                }
            }
            else {
                alt4 = 15;
            }
            }
            break;
        case '{': ;
            {
            alt4=13;
            }
            break;
        case '}': ;
            {
            alt4=14;
            }
            break;
        case 'A': ;
        case 'B': ;
        case 'C': ;
        case 'D': ;
        case 'E': ;
        case 'F': ;
        case 'G': ;
        case 'H': ;
        case 'I': ;
        case 'J': ;
        case 'K': ;
        case 'L': ;
        case 'M': ;
        case 'N': ;
        case 'O': ;
        case 'P': ;
        case 'Q': ;
        case 'R': ;
        case 'S': ;
        case 'T': ;
        case 'U': ;
        case 'V': ;
        case 'W': ;
        case 'X': ;
        case 'Y': ;
        case 'Z': ;
        case '_': ;
        case 'a': ;
        case 'b': ;
        case 'd': ;
        case 'e': ;
        case 'g': ;
        case 'h': ;
        case 'j': ;
        case 'k': ;
        case 'l': ;
        case 'm': ;
        case 'n': ;
        case 'o': ;
        case 'p': ;
        case 'q': ;
        case 'r': ;
        case 's': ;
        case 't': ;
        case 'u': ;
        case 'w': ;
        case 'x': ;
        case 'y': ;
        case 'z': ;
            {
            alt4=15;
            }
            break;
        case '0': ;
        case '1': ;
        case '2': ;
        case '3': ;
        case '4': ;
        case '5': ;
        case '6': ;
        case '7': ;
        case '8': ;
        case '9': ;
            {
            alt4=16;
            }
            break;
        case '\t': ;
        case '\n': ;
        case '\r': ;
        case ' ': ;
            {
            alt4=17;
            }
            break;

    default: ;
        ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:4 state:0 stream:input];
        nvae.c = charLA4;
        @throw nvae;

    }

    switch (alt4) {
        case 1 : ;
            // SimpleC.g:1:10: T__7 // alt
            {
            [self mT__7]; 



            }
            break;
        case 2 : ;
            // SimpleC.g:1:15: T__8 // alt
            {
            [self mT__8]; 



            }
            break;
        case 3 : ;
            // SimpleC.g:1:20: T__9 // alt
            {
            [self mT__9]; 



            }
            break;
        case 4 : ;
            // SimpleC.g:1:25: T__10 // alt
            {
            [self mT__10]; 



            }
            break;
        case 5 : ;
            // SimpleC.g:1:31: T__11 // alt
            {
            [self mT__11]; 



            }
            break;
        case 6 : ;
            // SimpleC.g:1:37: T__12 // alt
            {
            [self mT__12]; 



            }
            break;
        case 7 : ;
            // SimpleC.g:1:43: T__13 // alt
            {
            [self mT__13]; 



            }
            break;
        case 8 : ;
            // SimpleC.g:1:49: T__14 // alt
            {
            [self mT__14]; 



            }
            break;
        case 9 : ;
            // SimpleC.g:1:55: T__15 // alt
            {
            [self mT__15]; 



            }
            break;
        case 10 : ;
            // SimpleC.g:1:61: T__16 // alt
            {
            [self mT__16]; 



            }
            break;
        case 11 : ;
            // SimpleC.g:1:67: T__17 // alt
            {
            [self mT__17]; 



            }
            break;
        case 12 : ;
            // SimpleC.g:1:73: T__18 // alt
            {
            [self mT__18]; 



            }
            break;
        case 13 : ;
            // SimpleC.g:1:79: T__19 // alt
            {
            [self mT__19]; 



            }
            break;
        case 14 : ;
            // SimpleC.g:1:85: T__20 // alt
            {
            [self mT__20]; 



            }
            break;
        case 15 : ;
            // SimpleC.g:1:91: ID // alt
            {
            [self mID]; 



            }
            break;
        case 16 : ;
            // SimpleC.g:1:94: INT // alt
            {
            [self mINT]; 



            }
            break;
        case 17 : ;
            // SimpleC.g:1:98: WS // alt
            {
            [self mWS]; 



            }
            break;

    }

}

@end /* end of SimpleCLexer implementation line 397 */