/** \file
 *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
 *
 *     -  From the grammar source file : SimpleC.g
 *     -                            On : 2011-05-06 15:09:17
 *     -                for the parser : SimpleCParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// $ANTLR ${project.version} ${buildNumber} SimpleC.g 2011-05-06 15:09:17


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "SimpleCParser.h"
/* ----------------------------------------- */


/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */
#pragma mark Cyclic DFA implementation start DFA2
@implementation DFA2
const static NSInteger dfa2_eot[13] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa2_eof[13] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static unichar dfa2_min[13] =
    {9,14,18,9,0,14,17,10,0,0,9,14,10};
const static unichar dfa2_max[13] =
    {24,14,23,24,0,14,23,22,0,0,24,14,22};
const static NSInteger dfa2_accept[13] =
    {-1,-1,-1,-1,1,-1,-1,-1,2,3,-1,-1,-1};
const static NSInteger dfa2_special[13] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa2_transition[] = {};
const static NSInteger dfa2_transition0[] = {9, -1, -1, -1, -1, -1, 8};
const static NSInteger dfa2_transition1[] = {10, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, 6};
const static NSInteger dfa2_transition2[] = {5, -1, -1, -1, -1, 5, -1, 5, 
 -1, -1, -1, -1, -1, 6, -1, 5};
const static NSInteger dfa2_transition3[] = {11, -1, -1, -1, -1, 11, -1, 
 11, -1, -1, -1, -1, -1, -1, -1, 11};
const static NSInteger dfa2_transition4[] = {3, -1, -1, -1, -1, 4};
const static NSInteger dfa2_transition5[] = {1, -1, -1, -1, -1, 1, -1, 1, 
 -1, -1, -1, -1, -1, -1, -1, 1};
const static NSInteger dfa2_transition6[] = {7};
const static NSInteger dfa2_transition7[] = {12};
const static NSInteger dfa2_transition8[] = {2};


+ (id) newDFA2WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
{
    return [[[DFA2 alloc] initWithRecognizer:aRecognizer] retain];
}

- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
{
    self = [super initWithRecognizer:theRecognizer];
    if ( self != nil ) {
        decisionNumber = 2;
        eot = dfa2_eot;
        eof = dfa2_eof;
        min = dfa2_min;
        max = dfa2_max;
        accept = dfa2_accept;
        special = dfa2_special;
        if (!(transition = calloc(13, sizeof(void*)))) {
            [self release];
            return nil;
        }
        len = 13;
        transition[0] = dfa2_transition5;
        transition[1] = dfa2_transition8;
        transition[2] = dfa2_transition4;
        transition[3] = dfa2_transition2;

        transition[4] = dfa2_transition6;
        transition[5] = dfa2_transition0;
        transition[6] = dfa2_transition1;


        transition[7] = dfa2_transition3;
        transition[8] = dfa2_transition7;
        transition[9] = dfa2_transition1;
    }
    return self;
}

- (void) dealloc
{
    free(transition);
    [super dealloc];
}

- (NSString *) description
{
    return @"20:1: declaration : ( variable | functionHeader K_SEMICOLON -> ^( FUNC_DECL functionHeader ) | functionHeader block -> ^( FUNC_DEF functionHeader block ) );";
}


@end /* end DFA2 implementation */

#pragma mark Cyclic DFA implementation end DFA2



#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_declaration_in_program85;
static const unsigned long long FOLLOW_declaration_in_program85_data[] = { 0x0000000001014202LL};
static ANTLRBitSet *FOLLOW_variable_in_declaration105;
static const unsigned long long FOLLOW_variable_in_declaration105_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_functionHeader_in_declaration115;
static const unsigned long long FOLLOW_functionHeader_in_declaration115_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_declaration117;
static const unsigned long long FOLLOW_K_SEMICOLON_in_declaration117_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_functionHeader_in_declaration135;
static const unsigned long long FOLLOW_functionHeader_in_declaration135_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_block_in_declaration137;
static const unsigned long long FOLLOW_block_in_declaration137_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_type_in_variable166;
static const unsigned long long FOLLOW_type_in_variable166_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_declarator_in_variable168;
static const unsigned long long FOLLOW_declarator_in_variable168_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_variable170;
static const unsigned long long FOLLOW_K_SEMICOLON_in_variable170_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_ID_in_declarator199;
static const unsigned long long FOLLOW_K_ID_in_declarator199_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_type_in_functionHeader219;
static const unsigned long long FOLLOW_type_in_functionHeader219_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_K_ID_in_functionHeader221;
static const unsigned long long FOLLOW_K_ID_in_functionHeader221_data[] = { 0x0000000000040000LL};
static ANTLRBitSet *FOLLOW_K_LCURVE_in_functionHeader223;
static const unsigned long long FOLLOW_K_LCURVE_in_functionHeader223_data[] = { 0x0000000001414200LL};
static ANTLRBitSet *FOLLOW_formalParameter_in_functionHeader227;
static const unsigned long long FOLLOW_formalParameter_in_functionHeader227_data[] = { 0x0000000000400400LL};
static ANTLRBitSet *FOLLOW_K_COMMA_in_functionHeader231;
static const unsigned long long FOLLOW_K_COMMA_in_functionHeader231_data[] = { 0x0000000001014200LL};
static ANTLRBitSet *FOLLOW_formalParameter_in_functionHeader233;
static const unsigned long long FOLLOW_formalParameter_in_functionHeader233_data[] = { 0x0000000000400400LL};
static ANTLRBitSet *FOLLOW_K_RCURVE_in_functionHeader241;
static const unsigned long long FOLLOW_K_RCURVE_in_functionHeader241_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_type_in_formalParameter281;
static const unsigned long long FOLLOW_type_in_formalParameter281_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_declarator_in_formalParameter283;
static const unsigned long long FOLLOW_declarator_in_formalParameter283_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_LCURLY_in_block376;
static const unsigned long long FOLLOW_K_LCURLY_in_block376_data[] = { 0x0000000001A7E200LL};
static ANTLRBitSet *FOLLOW_variable_in_block390;
static const unsigned long long FOLLOW_variable_in_block390_data[] = { 0x0000000001A7E200LL};
static ANTLRBitSet *FOLLOW_stat_in_block405;
static const unsigned long long FOLLOW_stat_in_block405_data[] = { 0x0000000000A6E000LL};
static ANTLRBitSet *FOLLOW_K_RCURLY_in_block416;
static const unsigned long long FOLLOW_K_RCURLY_in_block416_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_forStat_in_stat449;
static const unsigned long long FOLLOW_forStat_in_stat449_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_expr_in_stat457;
static const unsigned long long FOLLOW_expr_in_stat457_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_stat459;
static const unsigned long long FOLLOW_K_SEMICOLON_in_stat459_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_block_in_stat468;
static const unsigned long long FOLLOW_block_in_stat468_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_assignStat_in_stat476;
static const unsigned long long FOLLOW_assignStat_in_stat476_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_stat478;
static const unsigned long long FOLLOW_K_SEMICOLON_in_stat478_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_stat487;
static const unsigned long long FOLLOW_K_SEMICOLON_in_stat487_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_FOR_in_forStat507;
static const unsigned long long FOLLOW_K_FOR_in_forStat507_data[] = { 0x0000000000040000LL};
static ANTLRBitSet *FOLLOW_K_LCURVE_in_forStat509;
static const unsigned long long FOLLOW_K_LCURVE_in_forStat509_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_assignStat_in_forStat513;
static const unsigned long long FOLLOW_assignStat_in_forStat513_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_forStat515;
static const unsigned long long FOLLOW_K_SEMICOLON_in_forStat515_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat517;
static const unsigned long long FOLLOW_expr_in_forStat517_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_forStat519;
static const unsigned long long FOLLOW_K_SEMICOLON_in_forStat519_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_assignStat_in_forStat523;
static const unsigned long long FOLLOW_assignStat_in_forStat523_data[] = { 0x0000000000400000LL};
static ANTLRBitSet *FOLLOW_K_RCURVE_in_forStat525;
static const unsigned long long FOLLOW_K_RCURVE_in_forStat525_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_block_in_forStat527;
static const unsigned long long FOLLOW_block_in_forStat527_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_ID_in_assignStat570;
static const unsigned long long FOLLOW_K_ID_in_assignStat570_data[] = { 0x0000000000000800LL};
static ANTLRBitSet *FOLLOW_K_EQ_in_assignStat572;
static const unsigned long long FOLLOW_K_EQ_in_assignStat572_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_expr_in_assignStat574;
static const unsigned long long FOLLOW_expr_in_assignStat574_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_condExpr_in_expr598;
static const unsigned long long FOLLOW_condExpr_in_expr598_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_aexpr_in_condExpr617;
static const unsigned long long FOLLOW_aexpr_in_condExpr617_data[] = { 0x0000000000081002LL};
static ANTLRBitSet *FOLLOW_K_EQEQ_in_condExpr622;
static const unsigned long long FOLLOW_K_EQEQ_in_condExpr622_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_K_LT_in_condExpr627;
static const unsigned long long FOLLOW_K_LT_in_condExpr627_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_aexpr_in_condExpr631;
static const unsigned long long FOLLOW_aexpr_in_condExpr631_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_atom_in_aexpr653;
static const unsigned long long FOLLOW_atom_in_aexpr653_data[] = { 0x0000000000100002LL};
static ANTLRBitSet *FOLLOW_K_PLUS_in_aexpr657;
static const unsigned long long FOLLOW_K_PLUS_in_aexpr657_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_atom_in_aexpr660;
static const unsigned long long FOLLOW_atom_in_aexpr660_data[] = { 0x0000000000100002LL};
static ANTLRBitSet *FOLLOW_K_ID_in_atom680;
static const unsigned long long FOLLOW_K_ID_in_atom680_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_INT_in_atom694;
static const unsigned long long FOLLOW_K_INT_in_atom694_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_LCURVE_in_atom708;
static const unsigned long long FOLLOW_K_LCURVE_in_atom708_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_expr_in_atom710;
static const unsigned long long FOLLOW_expr_in_atom710_data[] = { 0x0000000000400000LL};
static ANTLRBitSet *FOLLOW_K_RCURVE_in_atom712;
static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x0000000000000002LL};


#pragma mark Dynamic Global Scopes

#pragma mark Dynamic Rule Scopes

#pragma mark Rule Return Scopes start
@implementation SimpleCParser_program_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_program_return *)newSimpleCParser_program_return
{
    return [[[SimpleCParser_program_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_declaration_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_declaration_return *)newSimpleCParser_declaration_return
{
    return [[[SimpleCParser_declaration_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_variable_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_variable_return *)newSimpleCParser_variable_return
{
    return [[[SimpleCParser_variable_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_declarator_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_declarator_return *)newSimpleCParser_declarator_return
{
    return [[[SimpleCParser_declarator_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_functionHeader_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_functionHeader_return *)newSimpleCParser_functionHeader_return
{
    return [[[SimpleCParser_functionHeader_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_formalParameter_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_formalParameter_return *)newSimpleCParser_formalParameter_return
{
    return [[[SimpleCParser_formalParameter_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_type_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_type_return *)newSimpleCParser_type_return
{
    return [[[SimpleCParser_type_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_block_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_block_return *)newSimpleCParser_block_return
{
    return [[[SimpleCParser_block_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_stat_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_stat_return *)newSimpleCParser_stat_return
{
    return [[[SimpleCParser_stat_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_forStat_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_forStat_return *)newSimpleCParser_forStat_return
{
    return [[[SimpleCParser_forStat_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_assignStat_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_assignStat_return *)newSimpleCParser_assignStat_return
{
    return [[[SimpleCParser_assignStat_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_expr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_expr_return *)newSimpleCParser_expr_return
{
    return [[[SimpleCParser_expr_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_condExpr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_condExpr_return *)newSimpleCParser_condExpr_return
{
    return [[[SimpleCParser_condExpr_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_aexpr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_aexpr_return *)newSimpleCParser_aexpr_return
{
    return [[[SimpleCParser_aexpr_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation SimpleCParser_atom_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCParser_atom_return *)newSimpleCParser_atom_return
{
    return [[[SimpleCParser_atom_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


//#pragma mark Rule return scopes start
//

#pragma mark Rule return scopes start

@implementation SimpleCParser  // line 637

/* ObjC start of ruleAttributeScope */
#pragma mark Dynamic Rule Scopes
/* ObjC end of ruleAttributeScope */
#pragma mark global Attribute Scopes
/* ObjC start globalAttributeScope */
/* ObjC end globalAttributeScope */
/* ObjC start actions.(actionScope).synthesize */
/* ObjC end actions.(actionScope).synthesize */
/* ObjC start synthesize() */
/* AST genericParser.synthesize */
/* AST parserProperties */
@synthesize treeAdaptor;
/* ObjC end synthesize() */

+ (void) initialize
{
    #pragma mark Bitsets
    FOLLOW_declaration_in_program85 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declaration_in_program85_data Count:(NSUInteger)1] retain];
    FOLLOW_variable_in_declaration105 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_variable_in_declaration105_data Count:(NSUInteger)1] retain];
    FOLLOW_functionHeader_in_declaration115 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_functionHeader_in_declaration115_data Count:(NSUInteger)1] retain];
    FOLLOW_K_SEMICOLON_in_declaration117 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_SEMICOLON_in_declaration117_data Count:(NSUInteger)1] retain];
    FOLLOW_functionHeader_in_declaration135 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_functionHeader_in_declaration135_data Count:(NSUInteger)1] retain];
    FOLLOW_block_in_declaration137 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_block_in_declaration137_data Count:(NSUInteger)1] retain];
    FOLLOW_type_in_variable166 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_variable166_data Count:(NSUInteger)1] retain];
    FOLLOW_declarator_in_variable168 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declarator_in_variable168_data Count:(NSUInteger)1] retain];
    FOLLOW_K_SEMICOLON_in_variable170 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_SEMICOLON_in_variable170_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_declarator199 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_declarator199_data Count:(NSUInteger)1] retain];
    FOLLOW_type_in_functionHeader219 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_functionHeader219_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_functionHeader221 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_functionHeader221_data Count:(NSUInteger)1] retain];
    FOLLOW_K_LCURVE_in_functionHeader223 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_LCURVE_in_functionHeader223_data Count:(NSUInteger)1] retain];
    FOLLOW_formalParameter_in_functionHeader227 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_formalParameter_in_functionHeader227_data Count:(NSUInteger)1] retain];
    FOLLOW_K_COMMA_in_functionHeader231 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_COMMA_in_functionHeader231_data Count:(NSUInteger)1] retain];
    FOLLOW_formalParameter_in_functionHeader233 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_formalParameter_in_functionHeader233_data Count:(NSUInteger)1] retain];
    FOLLOW_K_RCURVE_in_functionHeader241 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_RCURVE_in_functionHeader241_data Count:(NSUInteger)1] retain];
    FOLLOW_type_in_formalParameter281 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_formalParameter281_data Count:(NSUInteger)1] retain];
    FOLLOW_declarator_in_formalParameter283 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declarator_in_formalParameter283_data Count:(NSUInteger)1] retain];
    FOLLOW_K_LCURLY_in_block376 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_LCURLY_in_block376_data Count:(NSUInteger)1] retain];
    FOLLOW_variable_in_block390 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_variable_in_block390_data Count:(NSUInteger)1] retain];
    FOLLOW_stat_in_block405 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_stat_in_block405_data Count:(NSUInteger)1] retain];
    FOLLOW_K_RCURLY_in_block416 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_RCURLY_in_block416_data Count:(NSUInteger)1] retain];
    FOLLOW_forStat_in_stat449 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_forStat_in_stat449_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_stat457 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_stat457_data Count:(NSUInteger)1] retain];
    FOLLOW_K_SEMICOLON_in_stat459 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_SEMICOLON_in_stat459_data Count:(NSUInteger)1] retain];
    FOLLOW_block_in_stat468 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_block_in_stat468_data Count:(NSUInteger)1] retain];
    FOLLOW_assignStat_in_stat476 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_assignStat_in_stat476_data Count:(NSUInteger)1] retain];
    FOLLOW_K_SEMICOLON_in_stat478 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_SEMICOLON_in_stat478_data Count:(NSUInteger)1] retain];
    FOLLOW_K_SEMICOLON_in_stat487 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_SEMICOLON_in_stat487_data Count:(NSUInteger)1] retain];
    FOLLOW_K_FOR_in_forStat507 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_FOR_in_forStat507_data Count:(NSUInteger)1] retain];
    FOLLOW_K_LCURVE_in_forStat509 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_LCURVE_in_forStat509_data Count:(NSUInteger)1] retain];
    FOLLOW_assignStat_in_forStat513 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_assignStat_in_forStat513_data Count:(NSUInteger)1] retain];
    FOLLOW_K_SEMICOLON_in_forStat515 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_SEMICOLON_in_forStat515_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_forStat517 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_forStat517_data Count:(NSUInteger)1] retain];
    FOLLOW_K_SEMICOLON_in_forStat519 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_SEMICOLON_in_forStat519_data Count:(NSUInteger)1] retain];
    FOLLOW_assignStat_in_forStat523 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_assignStat_in_forStat523_data Count:(NSUInteger)1] retain];
    FOLLOW_K_RCURVE_in_forStat525 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_RCURVE_in_forStat525_data Count:(NSUInteger)1] retain];
    FOLLOW_block_in_forStat527 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_block_in_forStat527_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_assignStat570 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_assignStat570_data Count:(NSUInteger)1] retain];
    FOLLOW_K_EQ_in_assignStat572 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_EQ_in_assignStat572_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_assignStat574 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_assignStat574_data Count:(NSUInteger)1] retain];
    FOLLOW_condExpr_in_expr598 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_condExpr_in_expr598_data Count:(NSUInteger)1] retain];
    FOLLOW_aexpr_in_condExpr617 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_aexpr_in_condExpr617_data Count:(NSUInteger)1] retain];
    FOLLOW_K_EQEQ_in_condExpr622 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_EQEQ_in_condExpr622_data Count:(NSUInteger)1] retain];
    FOLLOW_K_LT_in_condExpr627 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_LT_in_condExpr627_data Count:(NSUInteger)1] retain];
    FOLLOW_aexpr_in_condExpr631 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_aexpr_in_condExpr631_data Count:(NSUInteger)1] retain];
    FOLLOW_atom_in_aexpr653 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_atom_in_aexpr653_data Count:(NSUInteger)1] retain];
    FOLLOW_K_PLUS_in_aexpr657 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_PLUS_in_aexpr657_data Count:(NSUInteger)1] retain];
    FOLLOW_atom_in_aexpr660 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_atom_in_aexpr660_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_atom680 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_atom680_data Count:(NSUInteger)1] retain];
    FOLLOW_K_INT_in_atom694 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_INT_in_atom694_data Count:(NSUInteger)1] retain];
    FOLLOW_K_LCURVE_in_atom708 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_LCURVE_in_atom708_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_atom710 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_atom710_data Count:(NSUInteger)1] retain];
    FOLLOW_K_RCURVE_in_atom712 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_RCURVE_in_atom712_data Count:(NSUInteger)1] retain];

    [ANTLRBaseRecognizer setTokenNames:[[AMutableArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>", 
 @"ARG_DEF", @"BLOCK", @"FUNC_DECL", @"FUNC_DEF", @"FUNC_HDR", @"K_CHAR", 
 @"K_COMMA", @"K_EQ", @"K_EQEQ", @"K_FOR", @"K_ID", @"K_INT", @"K_INT_TYPE", 
 @"K_LCURLY", @"K_LCURVE", @"K_LT", @"K_PLUS", @"K_RCURLY", @"K_RCURVE", 
 @"K_SEMICOLON", @"K_VOID", @"VAR_DEF", @"WS", nil] retain]];
    [ANTLRBaseRecognizer setGrammarFileName:@"SimpleC.g"];
}

+ (SimpleCParser *)newSimpleCParser:(id<ANTLRTokenStream>)aStream
{
    return [[SimpleCParser alloc] initWithTokenStream:aStream];


}

- (id) initWithTokenStream:(id<ANTLRTokenStream>)aStream
{
    self = [super initWithTokenStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:15+1] retain]];
    if ( self != nil ) {


        dfa2 = [DFA2 newDFA2WithRecognizer:self];
        /* start of actions-actionScope-init */
        /* start of init */
        /* AST genericParser.init */
        [self setTreeAdaptor:[[ANTLRCommonTreeAdaptor newTreeAdaptor] retain]];
    }
    return self;
}

- (void) dealloc
{
    [dfa2 release];
    /* AST genericParser.dealloc */
    [self setTreeAdaptor:nil];

    [super dealloc];
}

/* ObjC start members */
/* ObjC end members */
/* ObjC start actions.(actionScope).methods */
/* ObjC end actions.(actionScope).methods */
/* ObjC start methods() */
/* AST genericParser.methods */
/* AST parserMethods */
- (id<ANTLRTreeAdaptor>) getTreeAdaptor
{
	return treeAdaptor;
}

- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor
{
	if (aTreeAdaptor != treeAdaptor) {
		treeAdaptor = aTreeAdaptor;
	}
}
/* ObjC end methods() */
/* ObjC start rules */
/*
 * $ANTLR start program
 * SimpleC.g:16:1: program : ( declaration )+ ;
 */
- (SimpleCParser_program_return *) program
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_program_return * retval = [SimpleCParser_program_return newSimpleCParser_program_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
         SimpleCParser_declaration_return * declaration1 = nil ;
         


        // SimpleC.g:17:5: ( ( declaration )+ ) // ruleBlockSingleAlt
        // SimpleC.g:17:9: ( declaration )+ // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


        // SimpleC.g:17:9: ( declaration )+ // positiveClosureBlock
        NSInteger cnt1 = 0;
        do {
            NSInteger alt1 = 2;
            NSInteger LA1_0 = [input LA:1];
            if ( (LA1_0==K_CHAR||LA1_0==K_ID||LA1_0==K_INT_TYPE||LA1_0==K_VOID) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 : ;
                    // SimpleC.g:17:9: declaration // alt
                    {
                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_declaration_in_program85];
                    declaration1 = [self declaration];

                    [self popFollow];


                    [treeAdaptor addChild:[declaration1 getTree] toTree:root_0];

                    }
                    break;

                default :
                    if ( cnt1 >= 1 )
                        goto loop1;
                    ANTLREarlyExitException *eee =
                        [ANTLREarlyExitException newException:input decisionNumber:1];
                    @throw eee;
            }
            cnt1++;
        } while (YES);
        loop1: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];



            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end program */

/*
 * $ANTLR start declaration
 * SimpleC.g:20:1: declaration : ( variable | functionHeader K_SEMICOLON -> ^( FUNC_DECL functionHeader ) | functionHeader block -> ^( FUNC_DEF functionHeader block ) );
 */
- (SimpleCParser_declaration_return *) declaration
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_declaration_return * retval = [SimpleCParser_declaration_return newSimpleCParser_declaration_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_SEMICOLON4 = nil;
         SimpleCParser_variable_return * variable2 = nil ;
         
         SimpleCParser_functionHeader_return * functionHeader3 = nil ;
         
         SimpleCParser_functionHeader_return * functionHeader5 = nil ;
         
         SimpleCParser_block_return * block6 = nil ;
         

        ANTLRCommonTree *K_SEMICOLON4_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_K_SEMICOLON =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_SEMICOLON"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_functionHeader =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule functionHeader"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_block =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule block"] retain];
        // SimpleC.g:21:5: ( variable | functionHeader K_SEMICOLON -> ^( FUNC_DECL functionHeader ) | functionHeader block -> ^( FUNC_DEF functionHeader block ) ) //ruleblock
        NSInteger alt2=3;
        alt2 = [dfa2 predict:input];
        switch (alt2) {
            case 1 : ;
                // SimpleC.g:21:9: variable // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_variable_in_declaration105];
                variable2 = [self variable];

                [self popFollow];


                [treeAdaptor addChild:[variable2 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // SimpleC.g:22:9: functionHeader K_SEMICOLON // alt
                {
                /* ruleRef */
                [self pushFollow:FOLLOW_functionHeader_in_declaration115];
                functionHeader3 = [self functionHeader];

                [self popFollow];


                [stream_functionHeader addElement:[functionHeader3 getTree]];

                K_SEMICOLON4=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_declaration117];  
                    [stream_K_SEMICOLON addElement:K_SEMICOLON4];


                // AST REWRITE
                // elements: functionHeader
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 22:36: -> ^( FUNC_DECL functionHeader )
                {
                    // SimpleC.g:22:39: ^( FUNC_DECL functionHeader )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
                                [treeAdaptor createTree:FUNC_DECL Text:@"FUNC_DECL"]
                         old:root_1];

                        [treeAdaptor addChild:[stream_functionHeader nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 3 : ;
                // SimpleC.g:23:9: functionHeader block // alt
                {
                /* ruleRef */
                [self pushFollow:FOLLOW_functionHeader_in_declaration135];
                functionHeader5 = [self functionHeader];

                [self popFollow];


                [stream_functionHeader addElement:[functionHeader5 getTree]];

                /* ruleRef */
                [self pushFollow:FOLLOW_block_in_declaration137];
                block6 = [self block];

                [self popFollow];


                [stream_block addElement:[block6 getTree]];

                // AST REWRITE
                // elements: functionHeader, block
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 23:30: -> ^( FUNC_DEF functionHeader block )
                {
                    // SimpleC.g:23:33: ^( FUNC_DEF functionHeader block )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
                                [treeAdaptor createTree:FUNC_DEF Text:@"FUNC_DEF"]
                         old:root_1];

                        [treeAdaptor addChild:[stream_functionHeader nextTree] toTree:root_1];

                        [treeAdaptor addChild:[stream_block nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


        [stream_K_SEMICOLON release];
        [stream_functionHeader release];
        [stream_block release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end declaration */

/*
 * $ANTLR start variable
 * SimpleC.g:26:1: variable : type declarator K_SEMICOLON -> ^( VAR_DEF type declarator ) ;
 */
- (SimpleCParser_variable_return *) variable
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_variable_return * retval = [SimpleCParser_variable_return newSimpleCParser_variable_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_SEMICOLON9 = nil;
         SimpleCParser_type_return * type7 = nil ;
         
         SimpleCParser_declarator_return * declarator8 = nil ;
         

        ANTLRCommonTree *K_SEMICOLON9_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_K_SEMICOLON =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_SEMICOLON"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_declarator =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule declarator"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_type =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule type"] retain];
        // SimpleC.g:27:5: ( type declarator K_SEMICOLON -> ^( VAR_DEF type declarator ) ) // ruleBlockSingleAlt
        // SimpleC.g:27:9: type declarator K_SEMICOLON // alt
        {
        /* ruleRef */
        [self pushFollow:FOLLOW_type_in_variable166];
        type7 = [self type];

        [self popFollow];


        [stream_type addElement:[type7 getTree]];

        /* ruleRef */
        [self pushFollow:FOLLOW_declarator_in_variable168];
        declarator8 = [self declarator];

        [self popFollow];


        [stream_declarator addElement:[declarator8 getTree]];

        K_SEMICOLON9=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_variable170];  
            [stream_K_SEMICOLON addElement:K_SEMICOLON9];


        // AST REWRITE
        // elements: declarator, type
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 27:37: -> ^( VAR_DEF type declarator )
        {
            // SimpleC.g:27:40: ^( VAR_DEF type declarator )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
                        [treeAdaptor createTree:VAR_DEF Text:@"VAR_DEF"]
                 old:root_1];

                [treeAdaptor addChild:[stream_type nextTree] toTree:root_1];

                [treeAdaptor addChild:[stream_declarator nextTree] toTree:root_1];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


        [stream_K_SEMICOLON release];
        [stream_declarator release];
        [stream_type release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end variable */

/*
 * $ANTLR start declarator
 * SimpleC.g:30:1: declarator : K_ID ;
 */
- (SimpleCParser_declarator_return *) declarator
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_declarator_return * retval = [SimpleCParser_declarator_return newSimpleCParser_declarator_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_ID10 = nil;

        ANTLRCommonTree *K_ID10_tree=nil;

        // SimpleC.g:31:5: ( K_ID ) // ruleBlockSingleAlt
        // SimpleC.g:31:9: K_ID // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


        /* ASTParser tokenRef */
        K_ID10=(ANTLRCommonToken *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_declarator199]; 
        K_ID10_tree = /* ASTParser createNodeFromToken */
        (ANTLRCommonTree *)[[treeAdaptor create:K_ID10] retain]
        ;
        [treeAdaptor addChild:K_ID10_tree  toTree:root_0];


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];



            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end declarator */

/*
 * $ANTLR start functionHeader
 * SimpleC.g:34:1: functionHeader : type K_ID K_LCURVE ( formalParameter ( K_COMMA formalParameter )* )? K_RCURVE -> ^( FUNC_HDR type K_ID ( formalParameter )+ ) ;
 */
- (SimpleCParser_functionHeader_return *) functionHeader
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_functionHeader_return * retval = [SimpleCParser_functionHeader_return newSimpleCParser_functionHeader_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_ID12 = nil;
        ANTLRCommonToken *K_LCURVE13 = nil;
        ANTLRCommonToken *K_COMMA15 = nil;
        ANTLRCommonToken *K_RCURVE17 = nil;
         SimpleCParser_type_return * type11 = nil ;
         
         SimpleCParser_formalParameter_return * formalParameter14 = nil ;
         
         SimpleCParser_formalParameter_return * formalParameter16 = nil ;
         

        ANTLRCommonTree *K_ID12_tree=nil;
        ANTLRCommonTree *K_LCURVE13_tree=nil;
        ANTLRCommonTree *K_COMMA15_tree=nil;
        ANTLRCommonTree *K_RCURVE17_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_K_ID =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_ID"] retain];
        ANTLRRewriteRuleTokenStream *stream_K_LCURVE =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_LCURVE"] retain];
        ANTLRRewriteRuleTokenStream *stream_K_RCURVE =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_RCURVE"] retain];
        ANTLRRewriteRuleTokenStream *stream_K_COMMA =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_COMMA"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_formalParameter =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule formalParameter"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_type =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule type"] retain];
        // SimpleC.g:35:5: ( type K_ID K_LCURVE ( formalParameter ( K_COMMA formalParameter )* )? K_RCURVE -> ^( FUNC_HDR type K_ID ( formalParameter )+ ) ) // ruleBlockSingleAlt
        // SimpleC.g:35:9: type K_ID K_LCURVE ( formalParameter ( K_COMMA formalParameter )* )? K_RCURVE // alt
        {
        /* ruleRef */
        [self pushFollow:FOLLOW_type_in_functionHeader219];
        type11 = [self type];

        [self popFollow];


        [stream_type addElement:[type11 getTree]];

        K_ID12=(ANTLRCommonToken *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_functionHeader221];  
            [stream_K_ID addElement:K_ID12];


        K_LCURVE13=(ANTLRCommonToken *)[self match:input TokenType:K_LCURVE Follow:FOLLOW_K_LCURVE_in_functionHeader223];  
            [stream_K_LCURVE addElement:K_LCURVE13];


        // SimpleC.g:35:28: ( formalParameter ( K_COMMA formalParameter )* )? // block
        NSInteger alt4=2;
        NSInteger LA4_0 = [input LA:1];

        if ( (LA4_0==K_CHAR||LA4_0==K_ID||LA4_0==K_INT_TYPE||LA4_0==K_VOID) ) {
            alt4=1;
        }
        switch (alt4) {
            case 1 : ;
                // SimpleC.g:35:30: formalParameter ( K_COMMA formalParameter )* // alt
                {
                /* ruleRef */
                [self pushFollow:FOLLOW_formalParameter_in_functionHeader227];
                formalParameter14 = [self formalParameter];

                [self popFollow];


                [stream_formalParameter addElement:[formalParameter14 getTree]];

                do {
                    NSInteger alt3=2;
                    NSInteger LA3_0 = [input LA:1];
                    if ( (LA3_0==K_COMMA) ) {
                        alt3=1;
                    }


                    switch (alt3) {
                        case 1 : ;
                            // SimpleC.g:35:48: K_COMMA formalParameter // alt
                            {
                            K_COMMA15=(ANTLRCommonToken *)[self match:input TokenType:K_COMMA Follow:FOLLOW_K_COMMA_in_functionHeader231];  
                                [stream_K_COMMA addElement:K_COMMA15];


                            /* ruleRef */
                            [self pushFollow:FOLLOW_formalParameter_in_functionHeader233];
                            formalParameter16 = [self formalParameter];

                            [self popFollow];


                            [stream_formalParameter addElement:[formalParameter16 getTree]];

                            }
                            break;

                        default :
                            goto loop3;
                    }
                } while (YES);
                loop3: ;


                }
                break;

        }


        K_RCURVE17=(ANTLRCommonToken *)[self match:input TokenType:K_RCURVE Follow:FOLLOW_K_RCURVE_in_functionHeader241];  
            [stream_K_RCURVE addElement:K_RCURVE17];


        // AST REWRITE
        // elements: formalParameter, type, K_ID
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 36:9: -> ^( FUNC_HDR type K_ID ( formalParameter )+ )
        {
            // SimpleC.g:36:12: ^( FUNC_HDR type K_ID ( formalParameter )+ )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
                        [treeAdaptor createTree:FUNC_HDR Text:@"FUNC_HDR"]
                 old:root_1];

                [treeAdaptor addChild:[stream_type nextTree] toTree:root_1];

                 // TODO: args: 
                [treeAdaptor addChild:
                            [stream_K_ID nextNode]
                 toTree:root_1];

                // SimpleC.g:36:33: ( formalParameter )+
                {
                if ( !([stream_formalParameter hasNext]) ) {
                    @throw [ANTLRRewriteEarlyExitException newException];
                }
                while ( [stream_formalParameter hasNext] ) {
                    [treeAdaptor addChild:[stream_formalParameter nextTree] toTree:root_1];

                }
                [stream_formalParameter reset];

                }
                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


        [stream_K_ID release];
        [stream_K_LCURVE release];
        [stream_K_RCURVE release];
        [stream_K_COMMA release];
        [stream_formalParameter release];
        [stream_type release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end functionHeader */

/*
 * $ANTLR start formalParameter
 * SimpleC.g:39:1: formalParameter : type declarator -> ^( ARG_DEF type declarator ) ;
 */
- (SimpleCParser_formalParameter_return *) formalParameter
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_formalParameter_return * retval = [SimpleCParser_formalParameter_return newSimpleCParser_formalParameter_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
         SimpleCParser_type_return * type18 = nil ;
         
         SimpleCParser_declarator_return * declarator19 = nil ;
         

        ANTLRRewriteRuleSubtreeStream *stream_declarator =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule declarator"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_type =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule type"] retain];
        // SimpleC.g:40:5: ( type declarator -> ^( ARG_DEF type declarator ) ) // ruleBlockSingleAlt
        // SimpleC.g:40:9: type declarator // alt
        {
        /* ruleRef */
        [self pushFollow:FOLLOW_type_in_formalParameter281];
        type18 = [self type];

        [self popFollow];


        [stream_type addElement:[type18 getTree]];

        /* ruleRef */
        [self pushFollow:FOLLOW_declarator_in_formalParameter283];
        declarator19 = [self declarator];

        [self popFollow];


        [stream_declarator addElement:[declarator19 getTree]];

        // AST REWRITE
        // elements: declarator, type
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 40:25: -> ^( ARG_DEF type declarator )
        {
            // SimpleC.g:40:28: ^( ARG_DEF type declarator )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
                        [treeAdaptor createTree:ARG_DEF Text:@"ARG_DEF"]
                 old:root_1];

                [treeAdaptor addChild:[stream_type nextTree] toTree:root_1];

                [treeAdaptor addChild:[stream_declarator nextTree] toTree:root_1];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


        [stream_declarator release];
        [stream_type release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end formalParameter */

/*
 * $ANTLR start type
 * SimpleC.g:43:1: type : ( K_INT_TYPE | K_CHAR | K_VOID | K_ID );
 */
- (SimpleCParser_type_return *) type
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_type_return * retval = [SimpleCParser_type_return newSimpleCParser_type_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *set20 = nil;

        ANTLRCommonTree *set20_tree=nil;

        // SimpleC.g:44:5: ( K_INT_TYPE | K_CHAR | K_VOID | K_ID ) // ruleBlockSingleAlt
        // SimpleC.g: // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


        /* ASTParser matchRuleBlockSet */
        /* ASTParser matchSet */
        set20 = (ANTLRCommonToken *)[input LT:1]; /* matchSet */

        if ([input LA:1] == K_CHAR||[input LA:1] == K_ID||[input LA:1] == K_INT_TYPE||[input LA:1] == K_VOID) {
            [input consume];
            [treeAdaptor addChild:/* ASTParser createNodeFromToken */
            (ANTLRCommonTree *)[[treeAdaptor create:set20] retain]
             toTree:root_0 ];
            [state setIsErrorRecovery:NO];
        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
            @throw mse;
        }


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];



            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end type */

/*
 * $ANTLR start block
 * SimpleC.g:50:1: block : lc= K_LCURLY ( variable )* ( stat )* K_RCURLY -> ^( BLOCK[$lc,@\"BLOCK\"] ( variable )* ( stat )* ) ;
 */
- (SimpleCParser_block_return *) block
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_block_return * retval = [SimpleCParser_block_return newSimpleCParser_block_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *lc = nil;
        ANTLRCommonToken *K_RCURLY23 = nil;
         SimpleCParser_variable_return * variable21 = nil ;
         
         SimpleCParser_stat_return * stat22 = nil ;
         

        ANTLRCommonTree *lc_tree=nil;
        ANTLRCommonTree *K_RCURLY23_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_K_LCURLY =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_LCURLY"] retain];
        ANTLRRewriteRuleTokenStream *stream_K_RCURLY =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_RCURLY"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_variable =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule variable"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_stat =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule stat"] retain];
        // SimpleC.g:51:5: (lc= K_LCURLY ( variable )* ( stat )* K_RCURLY -> ^( BLOCK[$lc,@\"BLOCK\"] ( variable )* ( stat )* ) ) // ruleBlockSingleAlt
        // SimpleC.g:51:9: lc= K_LCURLY ( variable )* ( stat )* K_RCURLY // alt
        {
        lc=(ANTLRCommonToken *)[self match:input TokenType:K_LCURLY Follow:FOLLOW_K_LCURLY_in_block376];  
            [stream_K_LCURLY addElement:lc];


        do {
            NSInteger alt5=2;
            NSInteger LA5_0 = [input LA:1];
            if ( (LA5_0==K_ID) ) {
                NSInteger LA5_2 = [input LA:2];
                if ( (LA5_2==K_ID) ) {
                    alt5=1;
                }


            }
            else if ( (LA5_0==K_CHAR||LA5_0==K_INT_TYPE||LA5_0==K_VOID) ) {
                alt5=1;
            }


            switch (alt5) {
                case 1 : ;
                    // SimpleC.g:52:13: variable // alt
                    {
                    /* ruleRef */
                    [self pushFollow:FOLLOW_variable_in_block390];
                    variable21 = [self variable];

                    [self popFollow];


                    [stream_variable addElement:[variable21 getTree]];

                    }
                    break;

                default :
                    goto loop5;
            }
        } while (YES);
        loop5: ;


        do {
            NSInteger alt6=2;
            NSInteger LA6_0 = [input LA:1];
            if ( ((LA6_0 >= K_FOR && LA6_0 <= K_INT)||(LA6_0 >= K_LCURLY && LA6_0 <= K_LCURVE)||LA6_0==K_SEMICOLON) ) {
                alt6=1;
            }


            switch (alt6) {
                case 1 : ;
                    // SimpleC.g:53:13: stat // alt
                    {
                    /* ruleRef */
                    [self pushFollow:FOLLOW_stat_in_block405];
                    stat22 = [self stat];

                    [self popFollow];


                    [stream_stat addElement:[stat22 getTree]];

                    }
                    break;

                default :
                    goto loop6;
            }
        } while (YES);
        loop6: ;


        K_RCURLY23=(ANTLRCommonToken *)[self match:input TokenType:K_RCURLY Follow:FOLLOW_K_RCURLY_in_block416];  
            [stream_K_RCURLY addElement:K_RCURLY23];


        // AST REWRITE
        // elements: stat, variable
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 55:9: -> ^( BLOCK[$lc,@\"BLOCK\"] ( variable )* ( stat )* )
        {
            // SimpleC.g:55:12: ^( BLOCK[$lc,@\"BLOCK\"] ( variable )* ( stat )* )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
                        [treeAdaptor createTree:BLOCK FromToken:lc Text:@"BLOCK"]
                 old:root_1];

                // SimpleC.g:55:34: ( variable )*
                while ( [stream_variable hasNext] ) {
                    [treeAdaptor addChild:[stream_variable nextTree] toTree:root_1];

                }
                [stream_variable reset];

                // SimpleC.g:55:44: ( stat )*
                while ( [stream_stat hasNext] ) {
                    [treeAdaptor addChild:[stream_stat nextTree] toTree:root_1];

                }
                [stream_stat reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


        [stream_K_LCURLY release];
        [stream_K_RCURLY release];
        [stream_variable release];
        [stream_stat release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end block */

/*
 * $ANTLR start stat
 * SimpleC.g:58:1: stat : ( forStat | expr K_SEMICOLON !| block | assignStat K_SEMICOLON !| K_SEMICOLON !);
 */
- (SimpleCParser_stat_return *) stat
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_stat_return * retval = [SimpleCParser_stat_return newSimpleCParser_stat_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_SEMICOLON26 = nil;
        ANTLRCommonToken *K_SEMICOLON29 = nil;
        ANTLRCommonToken *K_SEMICOLON30 = nil;
         SimpleCParser_forStat_return * forStat24 = nil ;
         
         SimpleCParser_expr_return * expr25 = nil ;
         
         SimpleCParser_block_return * block27 = nil ;
         
         SimpleCParser_assignStat_return * assignStat28 = nil ;
         

        ANTLRCommonTree *K_SEMICOLON26_tree=nil;
        ANTLRCommonTree *K_SEMICOLON29_tree=nil;
        ANTLRCommonTree *K_SEMICOLON30_tree=nil;

        // SimpleC.g:58:5: ( forStat | expr K_SEMICOLON !| block | assignStat K_SEMICOLON !| K_SEMICOLON !) //ruleblock
        NSInteger alt7=5;
        unichar charLA7 = [input LA:1];
        switch (charLA7) {
            case K_FOR: ;
                {
                alt7=1;
                }
                break;
            case K_ID: ;
                {
                NSInteger LA7_2 = [input LA:2];

                if ( (LA7_2==K_EQ) ) {
                    alt7=4;
                }
                else if ( (LA7_2==K_EQEQ||(LA7_2 >= K_LT && LA7_2 <= K_PLUS)||LA7_2==K_SEMICOLON) ) {
                    alt7=2;
                }
                else {
                    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:7 state:2 stream:input];
                    nvae.c = LA7_2;
                    @throw nvae;

                }
                }
                break;
            case K_INT: ;
            case K_LCURVE: ;
                {
                alt7=2;
                }
                break;
            case K_LCURLY: ;
                {
                alt7=3;
                }
                break;
            case K_SEMICOLON: ;
                {
                alt7=5;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:7 state:0 stream:input];
            nvae.c = charLA7;
            @throw nvae;

        }

        switch (alt7) {
            case 1 : ;
                // SimpleC.g:58:7: forStat // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_forStat_in_stat449];
                forStat24 = [self forStat];

                [self popFollow];


                [treeAdaptor addChild:[forStat24 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // SimpleC.g:59:7: expr K_SEMICOLON ! // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_expr_in_stat457];
                expr25 = [self expr];

                [self popFollow];


                [treeAdaptor addChild:[expr25 getTree] toTree:root_0];

                K_SEMICOLON26=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_stat459]; 

                }
                break;
            case 3 : ;
                // SimpleC.g:60:7: block // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_block_in_stat468];
                block27 = [self block];

                [self popFollow];


                [treeAdaptor addChild:[block27 getTree] toTree:root_0];

                }
                break;
            case 4 : ;
                // SimpleC.g:61:7: assignStat K_SEMICOLON ! // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_assignStat_in_stat476];
                assignStat28 = [self assignStat];

                [self popFollow];


                [treeAdaptor addChild:[assignStat28 getTree] toTree:root_0];

                K_SEMICOLON29=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_stat478]; 

                }
                break;
            case 5 : ;
                // SimpleC.g:62:7: K_SEMICOLON ! // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


                K_SEMICOLON30=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_stat487]; 

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];



            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end stat */

/*
 * $ANTLR start forStat
 * SimpleC.g:65:1: forStat : K_FOR K_LCURVE start= assignStat K_SEMICOLON expr K_SEMICOLON next= assignStat K_RCURVE block -> ^( K_FOR $start expr $next block ) ;
 */
- (SimpleCParser_forStat_return *) forStat
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_forStat_return * retval = [SimpleCParser_forStat_return newSimpleCParser_forStat_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_FOR31 = nil;
        ANTLRCommonToken *K_LCURVE32 = nil;
        ANTLRCommonToken *K_SEMICOLON33 = nil;
        ANTLRCommonToken *K_SEMICOLON35 = nil;
        ANTLRCommonToken *K_RCURVE36 = nil;
         SimpleCParser_assignStat_return * start = nil ;
         
         SimpleCParser_assignStat_return * next = nil ;
         
         SimpleCParser_expr_return * expr34 = nil ;
         
         SimpleCParser_block_return * block37 = nil ;
         

        ANTLRCommonTree *K_FOR31_tree=nil;
        ANTLRCommonTree *K_LCURVE32_tree=nil;
        ANTLRCommonTree *K_SEMICOLON33_tree=nil;
        ANTLRCommonTree *K_SEMICOLON35_tree=nil;
        ANTLRCommonTree *K_RCURVE36_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_K_LCURVE =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_LCURVE"] retain];
        ANTLRRewriteRuleTokenStream *stream_K_RCURVE =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_RCURVE"] retain];
        ANTLRRewriteRuleTokenStream *stream_K_SEMICOLON =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_SEMICOLON"] retain];
        ANTLRRewriteRuleTokenStream *stream_K_FOR =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_FOR"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_assignStat =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule assignStat"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_block =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule block"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_expr =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"] retain];
        // SimpleC.g:66:5: ( K_FOR K_LCURVE start= assignStat K_SEMICOLON expr K_SEMICOLON next= assignStat K_RCURVE block -> ^( K_FOR $start expr $next block ) ) // ruleBlockSingleAlt
        // SimpleC.g:66:9: K_FOR K_LCURVE start= assignStat K_SEMICOLON expr K_SEMICOLON next= assignStat K_RCURVE block // alt
        {
        K_FOR31=(ANTLRCommonToken *)[self match:input TokenType:K_FOR Follow:FOLLOW_K_FOR_in_forStat507];  
            [stream_K_FOR addElement:K_FOR31];


        K_LCURVE32=(ANTLRCommonToken *)[self match:input TokenType:K_LCURVE Follow:FOLLOW_K_LCURVE_in_forStat509];  
            [stream_K_LCURVE addElement:K_LCURVE32];


        /* ruleRef */
        [self pushFollow:FOLLOW_assignStat_in_forStat513];
        start = [self assignStat];

        [self popFollow];


        [stream_assignStat addElement:[start getTree]];

        K_SEMICOLON33=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_forStat515];  
            [stream_K_SEMICOLON addElement:K_SEMICOLON33];


        /* ruleRef */
        [self pushFollow:FOLLOW_expr_in_forStat517];
        expr34 = [self expr];

        [self popFollow];


        [stream_expr addElement:[expr34 getTree]];

        K_SEMICOLON35=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_forStat519];  
            [stream_K_SEMICOLON addElement:K_SEMICOLON35];


        /* ruleRef */
        [self pushFollow:FOLLOW_assignStat_in_forStat523];
        next = [self assignStat];

        [self popFollow];


        [stream_assignStat addElement:[next getTree]];

        K_RCURVE36=(ANTLRCommonToken *)[self match:input TokenType:K_RCURVE Follow:FOLLOW_K_RCURVE_in_forStat525];  
            [stream_K_RCURVE addElement:K_RCURVE36];


        /* ruleRef */
        [self pushFollow:FOLLOW_block_in_forStat527];
        block37 = [self block];

        [self popFollow];


        [stream_block addElement:[block37 getTree]];

        // AST REWRITE
        // elements: start, next, expr, block, K_FOR
        // token labels: 
        // rule labels: retval, start, next
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];
        ANTLRRewriteRuleSubtreeStream *stream_start =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token start" element:start!=nil?[start getTree]:nil] retain];
        ANTLRRewriteRuleSubtreeStream *stream_next =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token next" element:next!=nil?[next getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 67:9: -> ^( K_FOR $start expr $next block )
        {
            // SimpleC.g:67:12: ^( K_FOR $start expr $next block )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
                            [stream_K_FOR nextNode]
                 old:root_1];

                [treeAdaptor addChild:[stream_start nextTree] toTree:root_1];

                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                [treeAdaptor addChild:[stream_next nextTree] toTree:root_1];

                [treeAdaptor addChild:[stream_block nextTree] toTree:root_1];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


        [stream_K_LCURVE release];
        [stream_K_RCURVE release];
        [stream_K_SEMICOLON release];
        [stream_K_FOR release];
        [stream_assignStat release];
        [stream_block release];
        [stream_expr release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end forStat */

/*
 * $ANTLR start assignStat
 * SimpleC.g:70:1: assignStat : K_ID K_EQ expr -> ^( K_EQ K_ID expr ) ;
 */
- (SimpleCParser_assignStat_return *) assignStat
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_assignStat_return * retval = [SimpleCParser_assignStat_return newSimpleCParser_assignStat_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_ID38 = nil;
        ANTLRCommonToken *K_EQ39 = nil;
         SimpleCParser_expr_return * expr40 = nil ;
         

        ANTLRCommonTree *K_ID38_tree=nil;
        ANTLRCommonTree *K_EQ39_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_K_ID =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_ID"] retain];
        ANTLRRewriteRuleTokenStream *stream_K_EQ =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_EQ"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_expr =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"] retain];
        // SimpleC.g:71:5: ( K_ID K_EQ expr -> ^( K_EQ K_ID expr ) ) // ruleBlockSingleAlt
        // SimpleC.g:71:9: K_ID K_EQ expr // alt
        {
        K_ID38=(ANTLRCommonToken *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_assignStat570];  
            [stream_K_ID addElement:K_ID38];


        K_EQ39=(ANTLRCommonToken *)[self match:input TokenType:K_EQ Follow:FOLLOW_K_EQ_in_assignStat572];  
            [stream_K_EQ addElement:K_EQ39];


        /* ruleRef */
        [self pushFollow:FOLLOW_expr_in_assignStat574];
        expr40 = [self expr];

        [self popFollow];


        [stream_expr addElement:[expr40 getTree]];

        // AST REWRITE
        // elements: K_ID, K_EQ, expr
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 71:24: -> ^( K_EQ K_ID expr )
        {
            // SimpleC.g:71:27: ^( K_EQ K_ID expr )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
                            [stream_K_EQ nextNode]
                 old:root_1];

                 // TODO: args: 
                [treeAdaptor addChild:
                            [stream_K_ID nextNode]
                 toTree:root_1];

                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


        [stream_K_ID release];
        [stream_K_EQ release];
        [stream_expr release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end assignStat */

/*
 * $ANTLR start expr
 * SimpleC.g:74:1: expr : condExpr ;
 */
- (SimpleCParser_expr_return *) expr
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_expr_return * retval = [SimpleCParser_expr_return newSimpleCParser_expr_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
         SimpleCParser_condExpr_return * condExpr41 = nil ;
         


        // SimpleC.g:74:5: ( condExpr ) // ruleBlockSingleAlt
        // SimpleC.g:74:9: condExpr // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_condExpr_in_expr598];
        condExpr41 = [self condExpr];

        [self popFollow];


        [treeAdaptor addChild:[condExpr41 getTree] toTree:root_0];

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];



            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end expr */

/*
 * $ANTLR start condExpr
 * SimpleC.g:77:1: condExpr : aexpr ( ( K_EQEQ ^| K_LT ^) aexpr )? ;
 */
- (SimpleCParser_condExpr_return *) condExpr
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_condExpr_return * retval = [SimpleCParser_condExpr_return newSimpleCParser_condExpr_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_EQEQ43 = nil;
        ANTLRCommonToken *K_LT44 = nil;
         SimpleCParser_aexpr_return * aexpr42 = nil ;
         
         SimpleCParser_aexpr_return * aexpr45 = nil ;
         

        ANTLRCommonTree *K_EQEQ43_tree=nil;
        ANTLRCommonTree *K_LT44_tree=nil;

        // SimpleC.g:78:5: ( aexpr ( ( K_EQEQ ^| K_LT ^) aexpr )? ) // ruleBlockSingleAlt
        // SimpleC.g:78:9: aexpr ( ( K_EQEQ ^| K_LT ^) aexpr )? // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_aexpr_in_condExpr617];
        aexpr42 = [self aexpr];

        [self popFollow];


        [treeAdaptor addChild:[aexpr42 getTree] toTree:root_0];

        // SimpleC.g:78:15: ( ( K_EQEQ ^| K_LT ^) aexpr )? // block
        NSInteger alt9=2;
        NSInteger LA9_0 = [input LA:1];

        if ( (LA9_0==K_EQEQ||LA9_0==K_LT) ) {
            alt9=1;
        }
        switch (alt9) {
            case 1 : ;
                // SimpleC.g:78:17: ( K_EQEQ ^| K_LT ^) aexpr // alt
                {
                // SimpleC.g:78:17: ( K_EQEQ ^| K_LT ^) // block
                NSInteger alt8=2;
                NSInteger LA8_0 = [input LA:1];

                if ( (LA8_0==K_EQEQ) ) {
                    alt8=1;
                }
                else if ( (LA8_0==K_LT) ) {
                    alt8=2;
                }
                else {
                    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:8 state:0 stream:input];
                    nvae.c = LA8_0;
                    @throw nvae;

                }
                switch (alt8) {
                    case 1 : ;
                        // SimpleC.g:78:18: K_EQEQ ^ // alt
                        {
                        K_EQEQ43=(ANTLRCommonToken *)[self match:input TokenType:K_EQEQ Follow:FOLLOW_K_EQEQ_in_condExpr622]; 
                        K_EQEQ43_tree = /* ASTParser createNodeFromToken */
                        (ANTLRCommonTree *)[[treeAdaptor create:K_EQEQ43] retain]
                        ;
                        root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:K_EQEQ43_tree old:root_0];


                        }
                        break;
                    case 2 : ;
                        // SimpleC.g:78:28: K_LT ^ // alt
                        {
                        K_LT44=(ANTLRCommonToken *)[self match:input TokenType:K_LT Follow:FOLLOW_K_LT_in_condExpr627]; 
                        K_LT44_tree = /* ASTParser createNodeFromToken */
                        (ANTLRCommonTree *)[[treeAdaptor create:K_LT44] retain]
                        ;
                        root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:K_LT44_tree old:root_0];


                        }
                        break;

                }


                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_aexpr_in_condExpr631];
                aexpr45 = [self aexpr];

                [self popFollow];


                [treeAdaptor addChild:[aexpr45 getTree] toTree:root_0];

                }
                break;

        }


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];



            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end condExpr */

/*
 * $ANTLR start aexpr
 * SimpleC.g:81:1: aexpr : atom ( K_PLUS ^ atom )* ;
 */
- (SimpleCParser_aexpr_return *) aexpr
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_aexpr_return * retval = [SimpleCParser_aexpr_return newSimpleCParser_aexpr_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_PLUS47 = nil;
         SimpleCParser_atom_return * atom46 = nil ;
         
         SimpleCParser_atom_return * atom48 = nil ;
         

        ANTLRCommonTree *K_PLUS47_tree=nil;

        // SimpleC.g:82:5: ( atom ( K_PLUS ^ atom )* ) // ruleBlockSingleAlt
        // SimpleC.g:82:9: atom ( K_PLUS ^ atom )* // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_atom_in_aexpr653];
        atom46 = [self atom];

        [self popFollow];


        [treeAdaptor addChild:[atom46 getTree] toTree:root_0];

        do {
            NSInteger alt10=2;
            NSInteger LA10_0 = [input LA:1];
            if ( (LA10_0==K_PLUS) ) {
                alt10=1;
            }


            switch (alt10) {
                case 1 : ;
                    // SimpleC.g:82:16: K_PLUS ^ atom // alt
                    {
                    K_PLUS47=(ANTLRCommonToken *)[self match:input TokenType:K_PLUS Follow:FOLLOW_K_PLUS_in_aexpr657]; 
                    K_PLUS47_tree = /* ASTParser createNodeFromToken */
                    (ANTLRCommonTree *)[[treeAdaptor create:K_PLUS47] retain]
                    ;
                    root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:K_PLUS47_tree old:root_0];


                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_atom_in_aexpr660];
                    atom48 = [self atom];

                    [self popFollow];


                    [treeAdaptor addChild:[atom48 getTree] toTree:root_0];

                    }
                    break;

                default :
                    goto loop10;
            }
        } while (YES);
        loop10: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];



            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end aexpr */

/*
 * $ANTLR start atom
 * SimpleC.g:85:1: atom : ( K_ID | K_INT | K_LCURVE expr K_RCURVE -> expr );
 */
- (SimpleCParser_atom_return *) atom
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    /* AST ruleDeclarations */
    SimpleCParser_atom_return * retval = [SimpleCParser_atom_return newSimpleCParser_atom_return];
    [retval setStart:[input LT:1]];


    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *K_ID49 = nil;
        ANTLRCommonToken *K_INT50 = nil;
        ANTLRCommonToken *K_LCURVE51 = nil;
        ANTLRCommonToken *K_RCURVE53 = nil;
         SimpleCParser_expr_return * expr52 = nil ;
         

        ANTLRCommonTree *K_ID49_tree=nil;
        ANTLRCommonTree *K_INT50_tree=nil;
        ANTLRCommonTree *K_LCURVE51_tree=nil;
        ANTLRCommonTree *K_RCURVE53_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_K_LCURVE =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_LCURVE"] retain];
        ANTLRRewriteRuleTokenStream *stream_K_RCURVE =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token K_RCURVE"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_expr =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"] retain];
        // SimpleC.g:86:5: ( K_ID | K_INT | K_LCURVE expr K_RCURVE -> expr ) //ruleblock
        NSInteger alt11=3;
        unichar charLA11 = [input LA:1];
        switch (charLA11) {
            case K_ID: ;
                {
                alt11=1;
                }
                break;
            case K_INT: ;
                {
                alt11=2;
                }
                break;
            case K_LCURVE: ;
                {
                alt11=3;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:11 state:0 stream:input];
            nvae.c = charLA11;
            @throw nvae;

        }

        switch (alt11) {
            case 1 : ;
                // SimpleC.g:86:7: K_ID // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


                /* ASTParser tokenRef */
                K_ID49=(ANTLRCommonToken *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_atom680]; 
                K_ID49_tree = /* ASTParser createNodeFromToken */
                (ANTLRCommonTree *)[[treeAdaptor create:K_ID49] retain]
                ;
                [treeAdaptor addChild:K_ID49_tree  toTree:root_0];


                }
                break;
            case 2 : ;
                // SimpleC.g:87:7: K_INT // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


                /* ASTParser tokenRef */
                K_INT50=(ANTLRCommonToken *)[self match:input TokenType:K_INT Follow:FOLLOW_K_INT_in_atom694]; 
                K_INT50_tree = /* ASTParser createNodeFromToken */
                (ANTLRCommonTree *)[[treeAdaptor create:K_INT50] retain]
                ;
                [treeAdaptor addChild:K_INT50_tree  toTree:root_0];


                }
                break;
            case 3 : ;
                // SimpleC.g:88:7: K_LCURVE expr K_RCURVE // alt
                {
                K_LCURVE51=(ANTLRCommonToken *)[self match:input TokenType:K_LCURVE Follow:FOLLOW_K_LCURVE_in_atom708];  
                    [stream_K_LCURVE addElement:K_LCURVE51];


                /* ruleRef */
                [self pushFollow:FOLLOW_expr_in_atom710];
                expr52 = [self expr];

                [self popFollow];


                [stream_expr addElement:[expr52 getTree]];

                K_RCURVE53=(ANTLRCommonToken *)[self match:input TokenType:K_RCURVE Follow:FOLLOW_K_RCURVE_in_atom712];  
                    [stream_K_RCURVE addElement:K_RCURVE53];


                // AST REWRITE
                // elements: expr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 88:30: -> expr
                {
                    [treeAdaptor addChild:[stream_expr nextTree] toTree:root_0];

                }


                retval.tree = root_0;


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


        [stream_K_LCURVE release];
        [stream_K_RCURVE release];
        [stream_expr release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
        /* ASTParser rule.setErrorReturnValue */
        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];

    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end atom */
/* ObjC end rules */

@end /* end of SimpleCParser implementation line 692 */
