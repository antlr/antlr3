/** \file
 *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
 *
 *     -  From the grammar source file : SimpleCTP.g
 *     -                            On : 2011-05-06 15:09:28
 *     -           for the tree parser : SimpleCTPTreeParser
 *
 * Editing it, at least manually, is not wise.
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// $ANTLR ${project.version} ${buildNumber} SimpleCTP.g 2011-05-06 15:09:28


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "SimpleCTP.h"
/* ----------------------------------------- */


/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */

#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_declaration_in_program56;
static const unsigned long long FOLLOW_declaration_in_program56_data[] = { 0x00000000020000C2LL};
static ANTLRBitSet *FOLLOW_variable_in_declaration76;
static const unsigned long long FOLLOW_variable_in_declaration76_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_FUNC_DECL_in_declaration87;
static const unsigned long long FOLLOW_FUNC_DECL_in_declaration87_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_functionHeader_in_declaration89;
static const unsigned long long FOLLOW_functionHeader_in_declaration89_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_FUNC_DEF_in_declaration101;
static const unsigned long long FOLLOW_FUNC_DEF_in_declaration101_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_functionHeader_in_declaration103;
static const unsigned long long FOLLOW_functionHeader_in_declaration103_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_block_in_declaration105;
static const unsigned long long FOLLOW_block_in_declaration105_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_VAR_DEF_in_variable126;
static const unsigned long long FOLLOW_VAR_DEF_in_variable126_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_type_in_variable128;
static const unsigned long long FOLLOW_type_in_variable128_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_declarator_in_variable130;
static const unsigned long long FOLLOW_declarator_in_variable130_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_ID_in_declarator150;
static const unsigned long long FOLLOW_K_ID_in_declarator150_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_FUNC_HDR_in_functionHeader171;
static const unsigned long long FOLLOW_FUNC_HDR_in_functionHeader171_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_type_in_functionHeader173;
static const unsigned long long FOLLOW_type_in_functionHeader173_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_K_ID_in_functionHeader175;
static const unsigned long long FOLLOW_K_ID_in_functionHeader175_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_formalParameter_in_functionHeader177;
static const unsigned long long FOLLOW_formalParameter_in_functionHeader177_data[] = { 0x0000000000000018LL};
static ANTLRBitSet *FOLLOW_ARG_DEF_in_formalParameter199;
static const unsigned long long FOLLOW_ARG_DEF_in_formalParameter199_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_type_in_formalParameter201;
static const unsigned long long FOLLOW_type_in_formalParameter201_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_declarator_in_formalParameter203;
static const unsigned long long FOLLOW_declarator_in_formalParameter203_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_BLOCK_in_block283;
static const unsigned long long FOLLOW_BLOCK_in_block283_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_variable_in_block285;
static const unsigned long long FOLLOW_variable_in_block285_data[] = { 0x000000000218F828LL};
static ANTLRBitSet *FOLLOW_stat_in_block288;
static const unsigned long long FOLLOW_stat_in_block288_data[] = { 0x000000000018F828LL};
static ANTLRBitSet *FOLLOW_forStat_in_stat302;
static const unsigned long long FOLLOW_forStat_in_stat302_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_expr_in_stat310;
static const unsigned long long FOLLOW_expr_in_stat310_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_block_in_stat318;
static const unsigned long long FOLLOW_block_in_stat318_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_FOR_in_forStat338;
static const unsigned long long FOLLOW_K_FOR_in_forStat338_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat340;
static const unsigned long long FOLLOW_expr_in_forStat340_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat342;
static const unsigned long long FOLLOW_expr_in_forStat342_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat344;
static const unsigned long long FOLLOW_expr_in_forStat344_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_block_in_forStat346;
static const unsigned long long FOLLOW_block_in_forStat346_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_EQEQ_in_expr362;
static const unsigned long long FOLLOW_K_EQEQ_in_expr362_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_expr_in_expr364;
static const unsigned long long FOLLOW_expr_in_expr364_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_expr366;
static const unsigned long long FOLLOW_expr_in_expr366_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_LT_in_expr378;
static const unsigned long long FOLLOW_K_LT_in_expr378_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_expr_in_expr380;
static const unsigned long long FOLLOW_expr_in_expr380_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_expr382;
static const unsigned long long FOLLOW_expr_in_expr382_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_PLUS_in_expr394;
static const unsigned long long FOLLOW_K_PLUS_in_expr394_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_expr_in_expr396;
static const unsigned long long FOLLOW_expr_in_expr396_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_expr398;
static const unsigned long long FOLLOW_expr_in_expr398_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_EQ_in_expr410;
static const unsigned long long FOLLOW_K_EQ_in_expr410_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_K_ID_in_expr412;
static const unsigned long long FOLLOW_K_ID_in_expr412_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_expr416;
static const unsigned long long FOLLOW_expr_in_expr416_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_atom_in_expr429;
static const unsigned long long FOLLOW_atom_in_expr429_data[] = { 0x0000000000000002LL};


#pragma mark Dynamic Global Scopes
@implementation Symbols_Scope  /* globalAttributeScopeImplementation */
/* start of synthesize -- OBJC-Line 1750 */

@synthesize tree;

+ (Symbols_Scope *)newSymbols_Scope
{
    return [[[Symbols_Scope alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* start of iterate get and set functions */

- (ANTLRCommonTree *)gettree { return( tree ); }

- (void)settree:(ANTLRCommonTree *)aVal { tree = aVal; }

/* End of iterate get and set functions */

@end /* end of Symbols_Scope implementation */


#pragma mark Dynamic Rule Scopes

#pragma mark Rule Return Scopes start
@implementation SimpleCTP_expr_return /* returnScope */
 /* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCTP_expr_return *)newSimpleCTP_expr_return
{
    return [[[SimpleCTP_expr_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}



@end /* end of returnScope implementation */


//#pragma mark Rule return scopes start
//

#pragma mark Rule return scopes start

@implementation SimpleCTP  // line 637

/* ObjC start of ruleAttributeScope */
#pragma mark Dynamic Rule Scopes
/* ObjC end of ruleAttributeScope */
#pragma mark global Attribute Scopes
/* ObjC start globalAttributeScope */
static _stack;

/* ObjC end globalAttributeScope */
/* ObjC start actions.(actionScope).synthesize */
/* ObjC end actions.(actionScope).synthesize */
/* ObjC start synthesize() */
/* ObjC end synthesize() */

+ (void) initialize
{
    #pragma mark Bitsets
    FOLLOW_declaration_in_program56 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declaration_in_program56_data Count:(NSUInteger)1] retain];
    FOLLOW_variable_in_declaration76 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_variable_in_declaration76_data Count:(NSUInteger)1] retain];
    FOLLOW_FUNC_DECL_in_declaration87 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_FUNC_DECL_in_declaration87_data Count:(NSUInteger)1] retain];
    FOLLOW_functionHeader_in_declaration89 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_functionHeader_in_declaration89_data Count:(NSUInteger)1] retain];
    FOLLOW_FUNC_DEF_in_declaration101 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_FUNC_DEF_in_declaration101_data Count:(NSUInteger)1] retain];
    FOLLOW_functionHeader_in_declaration103 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_functionHeader_in_declaration103_data Count:(NSUInteger)1] retain];
    FOLLOW_block_in_declaration105 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_block_in_declaration105_data Count:(NSUInteger)1] retain];
    FOLLOW_VAR_DEF_in_variable126 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_VAR_DEF_in_variable126_data Count:(NSUInteger)1] retain];
    FOLLOW_type_in_variable128 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_variable128_data Count:(NSUInteger)1] retain];
    FOLLOW_declarator_in_variable130 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declarator_in_variable130_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_declarator150 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_declarator150_data Count:(NSUInteger)1] retain];
    FOLLOW_FUNC_HDR_in_functionHeader171 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_FUNC_HDR_in_functionHeader171_data Count:(NSUInteger)1] retain];
    FOLLOW_type_in_functionHeader173 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_functionHeader173_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_functionHeader175 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_functionHeader175_data Count:(NSUInteger)1] retain];
    FOLLOW_formalParameter_in_functionHeader177 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_formalParameter_in_functionHeader177_data Count:(NSUInteger)1] retain];
    FOLLOW_ARG_DEF_in_formalParameter199 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ARG_DEF_in_formalParameter199_data Count:(NSUInteger)1] retain];
    FOLLOW_type_in_formalParameter201 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_formalParameter201_data Count:(NSUInteger)1] retain];
    FOLLOW_declarator_in_formalParameter203 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declarator_in_formalParameter203_data Count:(NSUInteger)1] retain];
    FOLLOW_BLOCK_in_block283 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_BLOCK_in_block283_data Count:(NSUInteger)1] retain];
    FOLLOW_variable_in_block285 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_variable_in_block285_data Count:(NSUInteger)1] retain];
    FOLLOW_stat_in_block288 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_stat_in_block288_data Count:(NSUInteger)1] retain];
    FOLLOW_forStat_in_stat302 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_forStat_in_stat302_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_stat310 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_stat310_data Count:(NSUInteger)1] retain];
    FOLLOW_block_in_stat318 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_block_in_stat318_data Count:(NSUInteger)1] retain];
    FOLLOW_K_FOR_in_forStat338 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_FOR_in_forStat338_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_forStat340 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_forStat340_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_forStat342 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_forStat342_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_forStat344 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_forStat344_data Count:(NSUInteger)1] retain];
    FOLLOW_block_in_forStat346 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_block_in_forStat346_data Count:(NSUInteger)1] retain];
    FOLLOW_K_EQEQ_in_expr362 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_EQEQ_in_expr362_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr364 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr364_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr366 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr366_data Count:(NSUInteger)1] retain];
    FOLLOW_K_LT_in_expr378 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_LT_in_expr378_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr380 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr380_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr382 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr382_data Count:(NSUInteger)1] retain];
    FOLLOW_K_PLUS_in_expr394 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_PLUS_in_expr394_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr396 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr396_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr398 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr398_data Count:(NSUInteger)1] retain];
    FOLLOW_K_EQ_in_expr410 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_EQ_in_expr410_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_expr412 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_expr412_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr416 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr416_data Count:(NSUInteger)1] retain];
    FOLLOW_atom_in_expr429 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_atom_in_expr429_data Count:(NSUInteger)1] retain];

    [ANTLRBaseRecognizer setTokenNames:[[AMutableArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>", 
 @"ARG_DEF", @"BLOCK", @"FUNC_DECL", @"FUNC_DEF", @"FUNC_HDR", @"K_CHAR", 
 @"K_COMMA", @"K_EQ", @"K_EQEQ", @"K_FOR", @"K_ID", @"K_INT", @"K_INT_TYPE", 
 @"K_LCURLY", @"K_LCURVE", @"K_LT", @"K_PLUS", @"K_RCURLY", @"K_RCURVE", 
 @"K_SEMICOLON", @"K_VOID", @"VAR_DEF", @"WS", nil] retain]];
    [ANTLRBaseRecognizer setGrammarFileName:@"SimpleCTP.g"];
}

+ (SimpleCTP *)newSimpleCTP:(id<ANTLRTreeNodeStream>)aStream
{
    return [[SimpleCTP alloc] initWithStream:aStream];


}

- (id) initWithStream:(id<ANTLRTreeNodeStream>)aStream
{
    self = [super initWithStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:12+1] retain]];
    if ( self != nil ) {


        /* globalAttributeScopeInit */
        Symbols_scope = [Symbols_Scope newSymbols_Scope];
        Symbols_stack = [ANTLRSymbolStack newANTLRSymbolStackWithLen:30];
        /* start of actions-actionScope-init */
        /* start of init */
    }
    return self;
}

- (void) dealloc
{
    [Symbols_stack release];
    [super dealloc];
}

/* ObjC start members */
/* ObjC end members */
/* ObjC start actions.(actionScope).methods */
/* ObjC end actions.(actionScope).methods */
/* ObjC start methods() */
/* ObjC end methods() */
/* ObjC start rules */
/*
 * $ANTLR start program
 * SimpleCTP.g:13:1: program : ( declaration )+ ;
 */
- (void) program
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:14:5: ( ( declaration )+ ) // ruleBlockSingleAlt
        // SimpleCTP.g:14:9: ( declaration )+ // alt
        {
        // SimpleCTP.g:14:9: ( declaration )+ // positiveClosureBlock
        NSInteger cnt1 = 0;
        do {
            NSInteger alt1 = 2;
            NSInteger LA1_0 = [input LA:1];
            if ( ((LA1_0 >= FUNC_DECL && LA1_0 <= FUNC_DEF)||LA1_0==VAR_DEF) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 : ;
                    // SimpleCTP.g:14:9: declaration // alt
                    {
                    /* ruleRef */
                    [self pushFollow:FOLLOW_declaration_in_program56];
                    [self declaration];

                    [self popFollow];



                    }
                    break;

                default :
                    if ( cnt1 >= 1 )
                        goto loop1;
                    ANTLREarlyExitException *eee =
                        [ANTLREarlyExitException newException:input decisionNumber:1];
                    @throw eee;
            }
            cnt1++;
        } while (YES);
        loop1: ;


        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end program */

/*
 * $ANTLR start declaration
 * SimpleCTP.g:17:1: declaration : ( variable | ^( FUNC_DECL functionHeader ) | ^( FUNC_DEF functionHeader block ) );
 */
- (void) declaration
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:18:5: ( variable | ^( FUNC_DECL functionHeader ) | ^( FUNC_DEF functionHeader block ) ) //ruleblock
        NSInteger alt2=3;
        unichar charLA2 = [input LA:1];
        switch (charLA2) {
            case VAR_DEF: ;
                {
                alt2=1;
                }
                break;
            case FUNC_DECL: ;
                {
                alt2=2;
                }
                break;
            case FUNC_DEF: ;
                {
                alt2=3;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:2 state:0 stream:input];
            nvae.c = charLA2;
            @throw nvae;

        }

        switch (alt2) {
            case 1 : ;
                // SimpleCTP.g:18:9: variable // alt
                {
                /* ruleRef */
                [self pushFollow:FOLLOW_variable_in_declaration76];
                [self variable];

                [self popFollow];



                }
                break;
            case 2 : ;
                // SimpleCTP.g:19:9: ^( FUNC_DECL functionHeader ) // alt
                {
                [self match:input TokenType:FUNC_DECL Follow:FOLLOW_FUNC_DECL_in_declaration87]; 

                    [self match:input TokenType:DOWN Follow:nil]; 
                    /* ruleRef */
                    [self pushFollow:FOLLOW_functionHeader_in_declaration89];
                    [self functionHeader];

                    [self popFollow];



                    [self match:input TokenType:UP Follow:nil]; 


                }
                break;
            case 3 : ;
                // SimpleCTP.g:20:9: ^( FUNC_DEF functionHeader block ) // alt
                {
                [self match:input TokenType:FUNC_DEF Follow:FOLLOW_FUNC_DEF_in_declaration101]; 

                    [self match:input TokenType:DOWN Follow:nil]; 
                    /* ruleRef */
                    [self pushFollow:FOLLOW_functionHeader_in_declaration103];
                    [self functionHeader];

                    [self popFollow];



                    /* ruleRef */
                    [self pushFollow:FOLLOW_block_in_declaration105];
                    [self block];

                    [self popFollow];



                    [self match:input TokenType:UP Follow:nil]; 


                }
                break;

        }
        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end declaration */

/*
 * $ANTLR start variable
 * SimpleCTP.g:23:1: variable : ^( VAR_DEF type declarator ) ;
 */
- (void) variable
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:24:5: ( ^( VAR_DEF type declarator ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:24:9: ^( VAR_DEF type declarator ) // alt
        {
        [self match:input TokenType:VAR_DEF Follow:FOLLOW_VAR_DEF_in_variable126]; 

            [self match:input TokenType:DOWN Follow:nil]; 
            /* ruleRef */
            [self pushFollow:FOLLOW_type_in_variable128];
            [self type];

            [self popFollow];



            /* ruleRef */
            [self pushFollow:FOLLOW_declarator_in_variable130];
            [self declarator];

            [self popFollow];



            [self match:input TokenType:UP Follow:nil]; 


        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end variable */

/*
 * $ANTLR start declarator
 * SimpleCTP.g:27:1: declarator : K_ID ;
 */
- (void) declarator
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:28:5: ( K_ID ) // ruleBlockSingleAlt
        // SimpleCTP.g:28:9: K_ID // alt
        {
        [self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_declarator150]; 

        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end declarator */

/*
 * $ANTLR start functionHeader
 * SimpleCTP.g:31:1: functionHeader : ^( FUNC_HDR type K_ID ( formalParameter )+ ) ;
 */
- (void) functionHeader
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:32:5: ( ^( FUNC_HDR type K_ID ( formalParameter )+ ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:32:9: ^( FUNC_HDR type K_ID ( formalParameter )+ ) // alt
        {
        [self match:input TokenType:FUNC_HDR Follow:FOLLOW_FUNC_HDR_in_functionHeader171]; 

            [self match:input TokenType:DOWN Follow:nil]; 
            /* ruleRef */
            [self pushFollow:FOLLOW_type_in_functionHeader173];
            [self type];

            [self popFollow];



            [self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_functionHeader175]; 

            // SimpleCTP.g:32:30: ( formalParameter )+ // positiveClosureBlock
            NSInteger cnt3 = 0;
            do {
                NSInteger alt3 = 2;
                NSInteger LA3_0 = [input LA:1];
                if ( (LA3_0==ARG_DEF) ) {
                    alt3=1;
                }


                switch (alt3) {
                    case 1 : ;
                        // SimpleCTP.g:32:30: formalParameter // alt
                        {
                        /* ruleRef */
                        [self pushFollow:FOLLOW_formalParameter_in_functionHeader177];
                        [self formalParameter];

                        [self popFollow];



                        }
                        break;

                    default :
                        if ( cnt3 >= 1 )
                            goto loop3;
                        ANTLREarlyExitException *eee =
                            [ANTLREarlyExitException newException:input decisionNumber:3];
                        @throw eee;
                }
                cnt3++;
            } while (YES);
            loop3: ;


            [self match:input TokenType:UP Follow:nil]; 


        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end functionHeader */

/*
 * $ANTLR start formalParameter
 * SimpleCTP.g:35:1: formalParameter : ^( ARG_DEF type declarator ) ;
 */
- (void) formalParameter
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:36:5: ( ^( ARG_DEF type declarator ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:36:9: ^( ARG_DEF type declarator ) // alt
        {
        [self match:input TokenType:ARG_DEF Follow:FOLLOW_ARG_DEF_in_formalParameter199]; 

            [self match:input TokenType:DOWN Follow:nil]; 
            /* ruleRef */
            [self pushFollow:FOLLOW_type_in_formalParameter201];
            [self type];

            [self popFollow];



            /* ruleRef */
            [self pushFollow:FOLLOW_declarator_in_formalParameter203];
            [self declarator];

            [self popFollow];



            [self match:input TokenType:UP Follow:nil]; 


        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end formalParameter */

/*
 * $ANTLR start type
 * SimpleCTP.g:39:1: type : ( K_INT_TYPE | K_CHAR | K_VOID | K_ID );
 */
- (void) type
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:40:5: ( K_INT_TYPE | K_CHAR | K_VOID | K_ID ) // ruleBlockSingleAlt
        // SimpleCTP.g: // alt
        {
        if ([input LA:1] == K_CHAR||[input LA:1] == K_ID||[input LA:1] == K_INT_TYPE||[input LA:1] == K_VOID) {
            [input consume];
            [state setIsErrorRecovery:NO];
        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
            @throw mse;
        }


        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end type */

/*
 * $ANTLR start block
 * SimpleCTP.g:46:1: block : ^( BLOCK ( variable )* ( stat )* ) ;
 */
- (void) block
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:47:5: ( ^( BLOCK ( variable )* ( stat )* ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:47:9: ^( BLOCK ( variable )* ( stat )* ) // alt
        {
        [self match:input TokenType:BLOCK Follow:FOLLOW_BLOCK_in_block283]; 

        if ( [input LA:1] == DOWN ) {
            [self match:input TokenType:DOWN Follow:nil]; 
            do {
                NSInteger alt4=2;
                NSInteger LA4_0 = [input LA:1];
                if ( (LA4_0==VAR_DEF) ) {
                    alt4=1;
                }


                switch (alt4) {
                    case 1 : ;
                        // SimpleCTP.g:47:17: variable // alt
                        {
                        /* ruleRef */
                        [self pushFollow:FOLLOW_variable_in_block285];
                        [self variable];

                        [self popFollow];



                        }
                        break;

                    default :
                        goto loop4;
                }
            } while (YES);
            loop4: ;


            do {
                NSInteger alt5=2;
                NSInteger LA5_0 = [input LA:1];
                if ( (LA5_0==BLOCK||(LA5_0 >= K_EQ && LA5_0 <= K_INT)||(LA5_0 >= K_LT && LA5_0 <= K_PLUS)) ) {
                    alt5=1;
                }


                switch (alt5) {
                    case 1 : ;
                        // SimpleCTP.g:47:27: stat // alt
                        {
                        /* ruleRef */
                        [self pushFollow:FOLLOW_stat_in_block288];
                        [self stat];

                        [self popFollow];



                        }
                        break;

                    default :
                        goto loop5;
                }
            } while (YES);
            loop5: ;


            [self match:input TokenType:UP Follow:nil]; 
        }


        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end block */

/*
 * $ANTLR start stat
 * SimpleCTP.g:50:1: stat : ( forStat | expr | block );
 */
- (void) stat
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:50:5: ( forStat | expr | block ) //ruleblock
        NSInteger alt6=3;
        unichar charLA6 = [input LA:1];
        switch (charLA6) {
            case K_FOR: ;
                {
                alt6=1;
                }
                break;
            case K_EQ: ;
            case K_EQEQ: ;
            case K_ID: ;
            case K_INT: ;
            case K_LT: ;
            case K_PLUS: ;
                {
                alt6=2;
                }
                break;
            case BLOCK: ;
                {
                alt6=3;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:6 state:0 stream:input];
            nvae.c = charLA6;
            @throw nvae;

        }

        switch (alt6) {
            case 1 : ;
                // SimpleCTP.g:50:7: forStat // alt
                {
                /* ruleRef */
                [self pushFollow:FOLLOW_forStat_in_stat302];
                [self forStat];

                [self popFollow];



                }
                break;
            case 2 : ;
                // SimpleCTP.g:51:7: expr // alt
                {
                /* ruleRef */
                [self pushFollow:FOLLOW_expr_in_stat310];
                [self expr];

                [self popFollow];



                }
                break;
            case 3 : ;
                // SimpleCTP.g:52:7: block // alt
                {
                /* ruleRef */
                [self pushFollow:FOLLOW_block_in_stat318];
                [self block];

                [self popFollow];



                }
                break;

        }
        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end stat */

/*
 * $ANTLR start forStat
 * SimpleCTP.g:55:1: forStat : ^( K_FOR expr expr expr block ) ;
 */
- (void) forStat
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:56:5: ( ^( K_FOR expr expr expr block ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:56:9: ^( K_FOR expr expr expr block ) // alt
        {
        [self match:input TokenType:K_FOR Follow:FOLLOW_K_FOR_in_forStat338]; 

            [self match:input TokenType:DOWN Follow:nil]; 
            /* ruleRef */
            [self pushFollow:FOLLOW_expr_in_forStat340];
            [self expr];

            [self popFollow];



            /* ruleRef */
            [self pushFollow:FOLLOW_expr_in_forStat342];
            [self expr];

            [self popFollow];



            /* ruleRef */
            [self pushFollow:FOLLOW_expr_in_forStat344];
            [self expr];

            [self popFollow];



            /* ruleRef */
            [self pushFollow:FOLLOW_block_in_forStat346];
            [self block];

            [self popFollow];



            [self match:input TokenType:UP Follow:nil]; 


        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end forStat */

/*
 * $ANTLR start expr
 * SimpleCTP.g:59:1: expr : ( ^( K_EQEQ expr expr ) | ^( K_LT expr expr ) | ^( K_PLUS expr expr ) | ^( K_EQ K_ID e= expr ) | atom );
 */
- (SimpleCTP_expr_return *) expr
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    SimpleCTP_expr_return * retval = [SimpleCTP_expr_return newSimpleCTP_expr_return];
    [retval setStart:[input LT:1]];


    @try {
        ANTLRCommonTree *K_ID1 = nil;
         SimpleCTP_expr_return * e = nil ;
         

        // SimpleCTP.g:59:5: ( ^( K_EQEQ expr expr ) | ^( K_LT expr expr ) | ^( K_PLUS expr expr ) | ^( K_EQ K_ID e= expr ) | atom ) //ruleblock
        NSInteger alt7=5;
        unichar charLA7 = [input LA:1];
        switch (charLA7) {
            case K_EQEQ: ;
                {
                alt7=1;
                }
                break;
            case K_LT: ;
                {
                alt7=2;
                }
                break;
            case K_PLUS: ;
                {
                alt7=3;
                }
                break;
            case K_EQ: ;
                {
                alt7=4;
                }
                break;
            case K_ID: ;
            case K_INT: ;
                {
                alt7=5;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:7 state:0 stream:input];
            nvae.c = charLA7;
            @throw nvae;

        }

        switch (alt7) {
            case 1 : ;
                // SimpleCTP.g:59:9: ^( K_EQEQ expr expr ) // alt
                {
                [self match:input TokenType:K_EQEQ Follow:FOLLOW_K_EQEQ_in_expr362]; 

                    [self match:input TokenType:DOWN Follow:nil]; 
                    /* ruleRef */
                    [self pushFollow:FOLLOW_expr_in_expr364];
                    [self expr];

                    [self popFollow];



                    /* ruleRef */
                    [self pushFollow:FOLLOW_expr_in_expr366];
                    [self expr];

                    [self popFollow];



                    [self match:input TokenType:UP Follow:nil]; 


                }
                break;
            case 2 : ;
                // SimpleCTP.g:60:9: ^( K_LT expr expr ) // alt
                {
                [self match:input TokenType:K_LT Follow:FOLLOW_K_LT_in_expr378]; 

                    [self match:input TokenType:DOWN Follow:nil]; 
                    /* ruleRef */
                    [self pushFollow:FOLLOW_expr_in_expr380];
                    [self expr];

                    [self popFollow];



                    /* ruleRef */
                    [self pushFollow:FOLLOW_expr_in_expr382];
                    [self expr];

                    [self popFollow];



                    [self match:input TokenType:UP Follow:nil]; 


                }
                break;
            case 3 : ;
                // SimpleCTP.g:61:9: ^( K_PLUS expr expr ) // alt
                {
                [self match:input TokenType:K_PLUS Follow:FOLLOW_K_PLUS_in_expr394]; 

                    [self match:input TokenType:DOWN Follow:nil]; 
                    /* ruleRef */
                    [self pushFollow:FOLLOW_expr_in_expr396];
                    [self expr];

                    [self popFollow];



                    /* ruleRef */
                    [self pushFollow:FOLLOW_expr_in_expr398];
                    [self expr];

                    [self popFollow];



                    [self match:input TokenType:UP Follow:nil]; 


                }
                break;
            case 4 : ;
                // SimpleCTP.g:62:9: ^( K_EQ K_ID e= expr ) // alt
                {
                [self match:input TokenType:K_EQ Follow:FOLLOW_K_EQ_in_expr410]; 

                    [self match:input TokenType:DOWN Follow:nil]; 
                    K_ID1=(ANTLRCommonTree *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_expr412]; 

                    /* ruleRef */
                    [self pushFollow:FOLLOW_expr_in_expr416];
                    e = [self expr];

                    [self popFollow];



                    [self match:input TokenType:UP Follow:nil]; 


                 NSLog(@"assigning %@ to variable %@", (e!=nil?[[input getTokenStream] toStringFromStart:[[input getTreeAdaptor] getTokenStartIndex:[e getStart]]ToEnd:[[input getTreeAdaptor] getTokenStopIndex:[e getStart]]]:0), (K_ID1!=nil?K_ID1.text:nil)); 


                }
                break;
            case 5 : ;
                // SimpleCTP.g:63:9: atom // alt
                {
                /* ruleRef */
                [self pushFollow:FOLLOW_atom_in_expr429];
                [self atom];

                [self popFollow];



                }
                break;

        }
        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return retval;
}
/* $ANTLR end expr */

/*
 * $ANTLR start atom
 * SimpleCTP.g:66:1: atom : ( K_ID | K_INT );
 */
- (void) atom
{
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        // SimpleCTP.g:67:5: ( K_ID | K_INT ) // ruleBlockSingleAlt
        // SimpleCTP.g: // alt
        {
        if ((([input LA:1] >= K_ID) && ([input LA:1] <= K_INT))) {
            [input consume];
            [state setIsErrorRecovery:NO];
        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
            @throw mse;
        }


        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }

    @finally {
        /* Terence's stuff */

    }
    return ;
}
/* $ANTLR end atom */
/* ObjC end rules */

@end /* end of SimpleCTP implementation line 692 */
