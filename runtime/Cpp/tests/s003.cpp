#include "utils.hpp"
#include "UserTestTraits.hpp"
#include "s003Lexer.hpp"
#include "s003Parser.hpp"

#include <sys/types.h>

#include <iostream>
#include <sstream>
#include <fstream>

using namespace Antlr3Test;
using namespace std;

static    s003Lexer*		    lxr;

// Main entry point for this example
//
int 
main	(int argc, char *argv[])
{
	// Create the input stream based upon the argument supplied to us on the command line
	// for this example, the input will always default to ./input if there is no explicit
	// argument, otherwise we are expecting potentially a whole list of 'em.
	//
	if (argc < 2 || argv[1] == NULL)
	{
		Utils::processDir("./s003.input"); // Note in MSVC debug, working directory must be configured
	}
	else
	{
		int i;

		for (i = 1; i < argc; i++)
		{
			Utils::processDir(argv[i]);
		}
	}

	printf("finished parsing OK\n");	// Finnish parking is pretty good - I think it is all the snow

	return 0;
}

void parseFile(const char* fName, int fd)
{
	s003LexerTraits::InputStreamType*    input;
	s003LexerTraits::TokenStreamType*	tstream;
	s003Parser*			psr;
#if defined __linux
	string data = Utils::slurp(fd);
#else
	string data = Utils::slurp(fName);
#endif
	input	= new s003LexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
						   antlr3::ENC_8BIT,
						   data.length(), //strlen(data.c_str()),
						   (ANTLR_UINT8*)fName);
	// No case-sensitivity
	input->setUcaseLA(true);

	// Our input stream is now open and all set to go, so we can create a new instance of our
	// lexer and set the lexer input to our input stream:
	//  (file | memory | ?) --> inputstream -> lexer --> tokenstream --> parser ( --> treeparser )?
	//
	if (lxr == NULL)
	{
		lxr = new s003Lexer(input); 
	}
	else
	{
		lxr->setCharStream(input);
	}

	tstream = new s003LexerTraits::TokenStreamType(ANTLR_SIZE_HINT, lxr->get_tokSource());

	// Finally, now that we have our lexer constructed, we can create the parser
	//
	psr = new s003Parser(tstream);  // javaParserNew is generated by ANTLR3
	s003Parser::start_rule_return r = psr->start_rule();
	///std::cout << r.getTree()->toStringTree() << std::endl;
	std::cout << "Message: " << r.message << std::endl;
	std::cout << "Evaluator.Message: " << (r.evaluator ? r.evaluator->toString() : "NULL") << std::endl;

	putc('L', stdout); fflush(stdout);
	{
		ANTLR_INT32 T = 0;
		while	(T != s003Lexer::EOF_TOKEN)
		{
			T = tstream->LA(1);
			s003LexerTraits::CommonTokenType const* token = tstream->LT(1);
			ANTLR_UINT8 const *name = lxr->getTokenName(T);
			  
			printf("%d %s\t\"%s\"\n",
			       T,
			       name,
			       tstream->LT(1)->getText().c_str()
			       );
			tstream->consume();
		}
	}

	tstream->LT(1);	// Don't do this mormally, just causes lexer to run for timings here

	if(r.evaluator)
	{
		delete r.evaluator;
	}
	delete psr;
	delete tstream; 
	delete lxr; lxr = NULL;
	delete input; 
}
