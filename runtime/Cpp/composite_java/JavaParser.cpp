/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : Java.g
 *     -                            On : 2012-02-26 10:38:15
 *     -                for the parser : JavaParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "JavaParser.hpp"
/* ----------------------------------------- */

/** Exact same grammar as examples-v3/java/Java.g but broken into
 *  multiple pieces to illustrate composing grammars via import statement.
 *  Results in multiple classes with Java referring to others via
 *  delegation pattern.  Run ANTLR only once on this root grammar:
 *
 *		java org.antlr.Tool Java.g
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace  User  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   JavaParserTokenNames[110+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "CharacterLiteral",
        (ANTLR_UINT8*) "DecimalLiteral",
        (ANTLR_UINT8*) "ENUM",
        (ANTLR_UINT8*) "EscapeSequence",
        (ANTLR_UINT8*) "Exponent",
        (ANTLR_UINT8*) "FloatTypeSuffix",
        (ANTLR_UINT8*) "FloatingPointLiteral",
        (ANTLR_UINT8*) "HexDigit",
        (ANTLR_UINT8*) "HexLiteral",
        (ANTLR_UINT8*) "Identifier",
        (ANTLR_UINT8*) "IntegerTypeSuffix",
        (ANTLR_UINT8*) "JavaIDDigit",
        (ANTLR_UINT8*) "LINE_COMMENT",
        (ANTLR_UINT8*) "Letter",
        (ANTLR_UINT8*) "OctalEscape",
        (ANTLR_UINT8*) "OctalLiteral",
        (ANTLR_UINT8*) "StringLiteral",
        (ANTLR_UINT8*) "UnicodeEscape",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'!'",
        (ANTLR_UINT8*) "'!='",
        (ANTLR_UINT8*) "'%'",
        (ANTLR_UINT8*) "'%='",
        (ANTLR_UINT8*) "'&&'",
        (ANTLR_UINT8*) "'&'",
        (ANTLR_UINT8*) "'&='",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "'*'",
        (ANTLR_UINT8*) "'*='",
        (ANTLR_UINT8*) "'+'",
        (ANTLR_UINT8*) "'++'",
        (ANTLR_UINT8*) "'+='",
        (ANTLR_UINT8*) "','",
        (ANTLR_UINT8*) "'-'",
        (ANTLR_UINT8*) "'--'",
        (ANTLR_UINT8*) "'-='",
        (ANTLR_UINT8*) "'.'",
        (ANTLR_UINT8*) "'...'",
        (ANTLR_UINT8*) "'/'",
        (ANTLR_UINT8*) "'/='",
        (ANTLR_UINT8*) "':'",
        (ANTLR_UINT8*) "';'",
        (ANTLR_UINT8*) "'<'",
        (ANTLR_UINT8*) "'='",
        (ANTLR_UINT8*) "'=='",
        (ANTLR_UINT8*) "'>'",
        (ANTLR_UINT8*) "'?'",
        (ANTLR_UINT8*) "'@'",
        (ANTLR_UINT8*) "'['",
        (ANTLR_UINT8*) "']'",
        (ANTLR_UINT8*) "'^'",
        (ANTLR_UINT8*) "'^='",
        (ANTLR_UINT8*) "'abstract'",
        (ANTLR_UINT8*) "'assert'",
        (ANTLR_UINT8*) "'boolean'",
        (ANTLR_UINT8*) "'break'",
        (ANTLR_UINT8*) "'byte'",
        (ANTLR_UINT8*) "'case'",
        (ANTLR_UINT8*) "'catch'",
        (ANTLR_UINT8*) "'char'",
        (ANTLR_UINT8*) "'class'",
        (ANTLR_UINT8*) "'continue'",
        (ANTLR_UINT8*) "'default'",
        (ANTLR_UINT8*) "'do'",
        (ANTLR_UINT8*) "'double'",
        (ANTLR_UINT8*) "'else'",
        (ANTLR_UINT8*) "'extends'",
        (ANTLR_UINT8*) "'false'",
        (ANTLR_UINT8*) "'final'",
        (ANTLR_UINT8*) "'finally'",
        (ANTLR_UINT8*) "'float'",
        (ANTLR_UINT8*) "'for'",
        (ANTLR_UINT8*) "'if'",
        (ANTLR_UINT8*) "'implements'",
        (ANTLR_UINT8*) "'import'",
        (ANTLR_UINT8*) "'instanceof'",
        (ANTLR_UINT8*) "'int'",
        (ANTLR_UINT8*) "'interface'",
        (ANTLR_UINT8*) "'long'",
        (ANTLR_UINT8*) "'native'",
        (ANTLR_UINT8*) "'new'",
        (ANTLR_UINT8*) "'null'",
        (ANTLR_UINT8*) "'package'",
        (ANTLR_UINT8*) "'private'",
        (ANTLR_UINT8*) "'protected'",
        (ANTLR_UINT8*) "'public'",
        (ANTLR_UINT8*) "'return'",
        (ANTLR_UINT8*) "'short'",
        (ANTLR_UINT8*) "'static'",
        (ANTLR_UINT8*) "'strictfp'",
        (ANTLR_UINT8*) "'super'",
        (ANTLR_UINT8*) "'switch'",
        (ANTLR_UINT8*) "'synchronized'",
        (ANTLR_UINT8*) "'this'",
        (ANTLR_UINT8*) "'throw'",
        (ANTLR_UINT8*) "'throws'",
        (ANTLR_UINT8*) "'transient'",
        (ANTLR_UINT8*) "'true'",
        (ANTLR_UINT8*) "'try'",
        (ANTLR_UINT8*) "'void'",
        (ANTLR_UINT8*) "'volatile'",
        (ANTLR_UINT8*) "'while'",
        (ANTLR_UINT8*) "'{'",
        (ANTLR_UINT8*) "'|'",
        (ANTLR_UINT8*) "'|='",
        (ANTLR_UINT8*) "'||'",
        (ANTLR_UINT8*) "'}'",
        (ANTLR_UINT8*) "'~'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Java.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* JavaParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new JavaParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
JavaParser::JavaParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new JavaParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
JavaParser::JavaParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void JavaParser::init(StreamType* instream)
{
    /* Create a LIST for recording rule memos.
     */
     typedef RecognizerSharedStateType::RuleMemoType RuleMemoType;
     this->setRuleMemo( new RuleMemoType(15) );	/* 16 bit depth is enough for 32768 rules! */

	// Initialize the lexers that we are going to delegate some
	// functions to.
	//
	m_gJavaDecl = new Java_JavaDecl(instream, this->get_psrstate(), this);
	m_gJavaAnnotations = new Java_JavaAnnotations(instream, this->get_psrstate(), this);
	m_gJavaExpr = new Java_JavaExpr(instream, this->get_psrstate(), this);
	m_gJavaStat = new Java_JavaStat(instream, this->get_psrstate(), this);
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( JavaParserTokenNames );


}

void
JavaParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
JavaParser::~JavaParser()
 {
	// Free the parsers that we delegated to
	// functions to.NULL the state so we only free it once.
	//
	m_gJavaDecl->set_psrstate( NULL );
	         delete m_gJavaDecl;
	m_gJavaAnnotations->set_psrstate( NULL );
	         delete m_gJavaAnnotations;
	m_gJavaExpr->set_psrstate( NULL );
	         delete m_gJavaExpr;
	m_gJavaStat->set_psrstate( NULL );
	         delete m_gJavaStat;
	if(this->getRuleMemo() != NULL)
	{
		delete this->getRuleMemo();
		this->setRuleMemo(NULL);
	}
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return JavaParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: JavaParser  */
static	ANTLR_BITWORD FOLLOW_annotations_in_compilationUnit87_bits[]	= { ANTLR_UINT64_LIT(0x0420800000000082), ANTLR_UINT64_LIT(0x00000444CF290404) };
static  JavaParserImplTraits::BitsetListType FOLLOW_annotations_in_compilationUnit87( FOLLOW_annotations_in_compilationUnit87_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: JavaParser  */
static	ANTLR_BITWORD FOLLOW_packageDeclaration_in_compilationUnit92_bits[]	= { ANTLR_UINT64_LIT(0x0420800000000082), ANTLR_UINT64_LIT(0x00000444CE290404) };
static  JavaParserImplTraits::BitsetListType FOLLOW_packageDeclaration_in_compilationUnit92( FOLLOW_packageDeclaration_in_compilationUnit92_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: JavaParser  */
static	ANTLR_BITWORD FOLLOW_importDeclaration_in_compilationUnit103_bits[]	= { ANTLR_UINT64_LIT(0x0420800000000082), ANTLR_UINT64_LIT(0x00000444CE290404) };
static  JavaParserImplTraits::BitsetListType FOLLOW_importDeclaration_in_compilationUnit103( FOLLOW_importDeclaration_in_compilationUnit103_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: JavaParser  */
static	ANTLR_BITWORD FOLLOW_typeDeclaration_in_compilationUnit114_bits[]	= { ANTLR_UINT64_LIT(0x0420800000000082), ANTLR_UINT64_LIT(0x00000444CE280404) };
static  JavaParserImplTraits::BitsetListType FOLLOW_typeDeclaration_in_compilationUnit114( FOLLOW_typeDeclaration_in_compilationUnit114_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: JavaParser  */
static	ANTLR_BITWORD FOLLOW_annotations_in_synpred1_Java87_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  JavaParserImplTraits::BitsetListType FOLLOW_annotations_in_synpred1_Java87( FOLLOW_annotations_in_synpred1_Java87_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start compilationUnit
 * Java.g:25:1: compilationUnit : ( annotations )? ( packageDeclaration )? ( importDeclaration )* ( typeDeclaration )* ;
 */
void
JavaParser::compilationUnit()
{
        JavaParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ANTLR_MARKER compilationUnit_StartIndex;

    /* Initialize rule variables
     */
    compilationUnit_StartIndex = this->index();


    if ( (this->get_backtracking()>0) && (this->haveParsedRule(398)) )
    {
        {
        }



        return ;
    }


 
    {
        // Java.g:26:2: ( ( annotations )? ( packageDeclaration )? ( importDeclaration )* ( typeDeclaration )* )
        // Java.g:26:4: ( annotations )? ( packageDeclaration )? ( importDeclaration )* ( typeDeclaration )*
        {
            // Java.g:26:4: ( annotations )?
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                    case 53:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case Identifier:
                    		    	{
                    		    		{
                    		    		    int LA1_21 = this->LA(3);
                    		    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred1_Java>() )))
                    		    		    {
                    		    		        alt1=1;
                    		    		    }
                    		    		}
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt1)
                {
            	case 1:
            	    // Java.g:26:4: annotations
            	    {
            	        this->followPush(FOLLOW_annotations_in_compilationUnit87);
            	        annotations();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompilationUnitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // Java.g:27:3: ( packageDeclaration )?
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                    case 88:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2)
                {
            	case 1:
            	    // Java.g:27:3: packageDeclaration
            	    {
            	        this->followPush(FOLLOW_packageDeclaration_in_compilationUnit92);
            	        packageDeclaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompilationUnitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // Java.g:28:9: ( importDeclaration )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case 80:
                	{
                		alt3=1;
                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // Java.g:28:9: importDeclaration
            	    {
            	        this->followPush(FOLLOW_importDeclaration_in_compilationUnit103);
            	        importDeclaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompilationUnitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


            // Java.g:29:9: ( typeDeclaration )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case ENUM:
                case 47:
                case 53:
                case 58:
                case 66:
                case 74:
                case 83:
                case 85:
                case 89:
                case 90:
                case 91:
                case 94:
                case 95:
                case 98:
                case 102:
                case 106:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // Java.g:29:9: typeDeclaration
            	    {
            	        this->followPush(FOLLOW_typeDeclaration_in_compilationUnit114);
            	        typeDeclaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompilationUnitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompilationUnitEx; /* Prevent compiler warnings */
    rulecompilationUnitEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    if ( this->get_backtracking() > 0 ) { this->memoize(398, compilationUnit_StartIndex); }

    return ;
}
/* $ANTLR end compilationUnit */

// $ANTLR start synpred1_Java
void JavaParser::msynpred1_Java_fragment(  )
{
    // Java.g:26:4: ( annotations )
    // Java.g:26:4: annotations
    {
        this->followPush(FOLLOW_annotations_in_synpred1_Java87);
        annotations();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_JavaEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_JavaEx; /* Prevent compiler warnings */
rulesynpred1_JavaEx: ;

}
// $ANTLR end synpred1_Java
	// Delegated methods that appear to be a part of this
	// parser
	//
    void JavaParser::memberDecl()
    {
   m_gJavaDecl->memberDecl( );
	}

    void JavaParser::importDeclaration()
    {
   m_gJavaDecl->importDeclaration( );
	}

    void JavaParser::annotationMethodRest()
    {
   m_gJavaAnnotations->annotationMethodRest( );
	}

    void JavaParser::typeParameters()
    {
   m_gJavaDecl->typeParameters( );
	}

    void JavaParser::creator()
    {
   m_gJavaExpr->creator( );
	}

    void JavaParser::variableModifier()
    {
   m_gJavaDecl->variableModifier( );
	}

    void JavaParser::interfaceBody()
    {
   m_gJavaDecl->interfaceBody( );
	}

    void JavaParser::normalClassDeclaration()
    {
   m_gJavaDecl->normalClassDeclaration( );
	}

    void JavaParser::enumDeclaration()
    {
   m_gJavaDecl->enumDeclaration( );
	}

    void JavaParser::statementExpression()
    {
   m_gJavaExpr->statementExpression( );
	}

    void JavaParser::modifier()
    {
   m_gJavaDecl->modifier( );
	}

    void JavaParser::elementValuePair()
    {
   m_gJavaAnnotations->elementValuePair( );
	}

    void JavaParser::switchLabel()
    {
   m_gJavaStat->switchLabel( );
	}

    void JavaParser::qualifiedNameList()
    {
   m_gJavaDecl->qualifiedNameList( );
	}

    void JavaParser::genericMethodOrConstructorRest()
    {
   m_gJavaDecl->genericMethodOrConstructorRest( );
	}

    void JavaParser::interfaceMethodOrFieldDecl()
    {
   m_gJavaDecl->interfaceMethodOrFieldDecl( );
	}

    void JavaParser::interfaceMethodOrFieldRest()
    {
   m_gJavaDecl->interfaceMethodOrFieldRest( );
	}

    void JavaParser::classCreatorRest()
    {
   m_gJavaExpr->classCreatorRest( );
	}

    void JavaParser::explicitGenericInvocation()
    {
   m_gJavaExpr->explicitGenericInvocation( );
	}

    void JavaParser::voidInterfaceMethodDeclaratorRest()
    {
   m_gJavaDecl->voidInterfaceMethodDeclaratorRest( );
	}

    void JavaParser::primary()
    {
   m_gJavaExpr->primary( );
	}

    void JavaParser::genericMethodOrConstructorDecl()
    {
   m_gJavaDecl->genericMethodOrConstructorDecl( );
	}

    void JavaParser::additiveExpression()
    {
   m_gJavaExpr->additiveExpression( );
	}

    void JavaParser::methodDeclaration()
    {
   m_gJavaDecl->methodDeclaration( );
	}

    void JavaParser::inclusiveOrExpression()
    {
   m_gJavaExpr->inclusiveOrExpression( );
	}

    void JavaParser::classBodyDeclaration()
    {
   m_gJavaDecl->classBodyDeclaration( );
	}

    void JavaParser::forUpdate()
    {
   m_gJavaStat->forUpdate( );
	}

    void JavaParser::parExpression()
    {
   m_gJavaExpr->parExpression( );
	}

    void JavaParser::arrayInitializer()
    {
   m_gJavaDecl->arrayInitializer( );
	}

    void JavaParser::enumConstant()
    {
   m_gJavaDecl->enumConstant( );
	}

    void JavaParser::classOrInterfaceDeclaration()
    {
   m_gJavaDecl->classOrInterfaceDeclaration( );
	}

    void JavaParser::variableDeclarators()
    {
   m_gJavaDecl->variableDeclarators( );
	}

    void JavaParser::qualifiedName()
    {
   m_gJavaDecl->qualifiedName( );
	}

    void JavaParser::methodBody()
    {
   m_gJavaStat->methodBody( );
	}

    void JavaParser::variableInitializer()
    {
   m_gJavaDecl->variableInitializer( );
	}

    void JavaParser::block()
    {
   m_gJavaStat->block( );
	}

    void JavaParser::typeList()
    {
   m_gJavaDecl->typeList( );
	}

    void JavaParser::multiplicativeExpression()
    {
   m_gJavaExpr->multiplicativeExpression( );
	}

    void JavaParser::typeDeclaration()
    {
   m_gJavaDecl->typeDeclaration( );
	}

    void JavaParser::annotation()
    {
   m_gJavaAnnotations->annotation( );
	}

    void JavaParser::equalityExpression()
    {
   m_gJavaExpr->equalityExpression( );
	}

    void JavaParser::packageDeclaration()
    {
   m_gJavaDecl->packageDeclaration( );
	}

    void JavaParser::castExpression()
    {
   m_gJavaExpr->castExpression( );
	}

    void JavaParser::type()
    {
   m_gJavaDecl->type( );
	}

    void JavaParser::annotationTypeBody()
    {
   m_gJavaAnnotations->annotationTypeBody( );
	}

    void JavaParser::defaultValue()
    {
   m_gJavaAnnotations->defaultValue( );
	}

    void JavaParser::unaryExpressionNotPlusMinus()
    {
   m_gJavaExpr->unaryExpressionNotPlusMinus( );
	}

    void JavaParser::annotationMethodOrConstantRest()
    {
   m_gJavaAnnotations->annotationMethodOrConstantRest( );
	}

    void JavaParser::annotationTypeElementDeclarations()
    {
   m_gJavaAnnotations->annotationTypeElementDeclarations( );
	}

    void JavaParser::annotationName()
    {
   m_gJavaAnnotations->annotationName( );
	}

    void JavaParser::switchBlockStatementGroups()
    {
   m_gJavaStat->switchBlockStatementGroups( );
	}

    void JavaParser::enumBody()
    {
   m_gJavaDecl->enumBody( );
	}

    void JavaParser::blockStatement()
    {
   m_gJavaStat->blockStatement( );
	}

    void JavaParser::interfaceMemberDecl()
    {
   m_gJavaDecl->interfaceMemberDecl( );
	}

    void JavaParser::forControl()
    {
   m_gJavaStat->forControl( );
	}

    void JavaParser::innerCreator()
    {
   m_gJavaExpr->innerCreator( );
	}

    void JavaParser::identifierSuffix()
    {
   m_gJavaExpr->identifierSuffix( );
	}

    void JavaParser::relationalExpression()
    {
   m_gJavaExpr->relationalExpression( );
	}

    void JavaParser::typeArgument()
    {
   m_gJavaDecl->typeArgument( );
	}

    void JavaParser::localVariableDeclaration()
    {
   m_gJavaStat->localVariableDeclaration( );
	}

    void JavaParser::typeName()
    {
   m_gJavaDecl->typeName( );
	}

    void JavaParser::fieldDeclaration()
    {
   m_gJavaDecl->fieldDeclaration( );
	}

    void JavaParser::constantDeclaratorsRest()
    {
   m_gJavaDecl->constantDeclaratorsRest( );
	}

    void JavaParser::annotationConstantRest()
    {
   m_gJavaAnnotations->annotationConstantRest( );
	}

    void JavaParser::typeParameter()
    {
   m_gJavaDecl->typeParameter( );
	}

    void JavaParser::conditionalOrExpression()
    {
   m_gJavaExpr->conditionalOrExpression( );
	}

    void JavaParser::interfaceDeclaration()
    {
   m_gJavaDecl->interfaceDeclaration( );
	}

    void JavaParser::moreStatementExpressions()
    {
   m_gJavaStat->moreStatementExpressions( );
	}

    void JavaParser::statement()
    {
   m_gJavaStat->statement( );
	}

    void JavaParser::shiftOp()
    {
   m_gJavaExpr->shiftOp( );
	}

    void JavaParser::exclusiveOrExpression()
    {
   m_gJavaExpr->exclusiveOrExpression( );
	}

    void JavaParser::conditionalExpression()
    {
   m_gJavaExpr->conditionalExpression( );
	}

    void JavaParser::formalParameterDeclsRest()
    {
   m_gJavaDecl->formalParameterDeclsRest( );
	}

    void JavaParser::annotationTypeElementDeclaration()
    {
   m_gJavaAnnotations->annotationTypeElementDeclaration( );
	}

    void JavaParser::relationalOp()
    {
   m_gJavaExpr->relationalOp( );
	}

    void JavaParser::catchClause()
    {
   m_gJavaStat->catchClause( );
	}

    void JavaParser::elementValue()
    {
   m_gJavaAnnotations->elementValue( );
	}

    void JavaParser::voidMethodDeclaratorRest()
    {
   m_gJavaDecl->voidMethodDeclaratorRest( );
	}

    void JavaParser::arrayCreatorRest()
    {
   m_gJavaExpr->arrayCreatorRest( );
	}

    void JavaParser::arguments()
    {
   m_gJavaExpr->arguments( );
	}

    void JavaParser::forVarControl()
    {
   m_gJavaStat->forVarControl( );
	}

    void JavaParser::instanceOfExpression()
    {
   m_gJavaExpr->instanceOfExpression( );
	}

    void JavaParser::formalParameters()
    {
   m_gJavaDecl->formalParameters( );
	}

    void JavaParser::forInit()
    {
   m_gJavaStat->forInit( );
	}

    void JavaParser::shiftExpression()
    {
   m_gJavaExpr->shiftExpression( );
	}

    void JavaParser::variableDeclarator()
    {
   m_gJavaDecl->variableDeclarator( );
	}

    void JavaParser::unaryExpression()
    {
   m_gJavaExpr->unaryExpression( );
	}

    void JavaParser::enumConstantName()
    {
   m_gJavaDecl->enumConstantName( );
	}

    void JavaParser::elementValuePairs()
    {
   m_gJavaAnnotations->elementValuePairs( );
	}

    void JavaParser::annotations()
    {
   m_gJavaAnnotations->annotations( );
	}

    void JavaParser::interfaceGenericMethodDecl()
    {
   m_gJavaDecl->interfaceGenericMethodDecl( );
	}

    void JavaParser::catches()
    {
   m_gJavaStat->catches( );
	}

    void JavaParser::bound()
    {
   m_gJavaDecl->bound( );
	}

    void JavaParser::primitiveType()
    {
   m_gJavaDecl->primitiveType( );
	}

    void JavaParser::constantDeclaratorRest()
    {
   m_gJavaDecl->constantDeclaratorRest( );
	}

    void JavaParser::constructorDeclaratorRest()
    {
   m_gJavaDecl->constructorDeclaratorRest( );
	}

    void JavaParser::normalInterfaceDeclaration()
    {
   m_gJavaDecl->normalInterfaceDeclaration( );
	}

    void JavaParser::expressionList()
    {
   m_gJavaExpr->expressionList( );
	}

    void JavaParser::classBody()
    {
   m_gJavaDecl->classBody( );
	}

    void JavaParser::variableDeclaratorRest()
    {
   m_gJavaDecl->variableDeclaratorRest( );
	}

    void JavaParser::superSuffix()
    {
   m_gJavaExpr->superSuffix( );
	}

    void JavaParser::elementValueArrayInitializer()
    {
   m_gJavaAnnotations->elementValueArrayInitializer( );
	}

    void JavaParser::constantDeclarator()
    {
   m_gJavaDecl->constantDeclarator( );
	}

    void JavaParser::literal()
    {
   m_gJavaExpr->literal( );
	}

    void JavaParser::interfaceBodyDeclaration()
    {
   m_gJavaDecl->interfaceBodyDeclaration( );
	}

    void JavaParser::enumConstants()
    {
   m_gJavaDecl->enumConstants( );
	}

    void JavaParser::formalParameter()
    {
   m_gJavaStat->formalParameter( );
	}

    void JavaParser::interfaceMethodDeclaratorRest()
    {
   m_gJavaDecl->interfaceMethodDeclaratorRest( );
	}

    void JavaParser::typeArguments()
    {
   m_gJavaDecl->typeArguments( );
	}

    void JavaParser::createdName()
    {
   m_gJavaExpr->createdName( );
	}

    void JavaParser::conditionalAndExpression()
    {
   m_gJavaExpr->conditionalAndExpression( );
	}

    void JavaParser::nonWildcardTypeArguments()
    {
   m_gJavaExpr->nonWildcardTypeArguments( );
	}

    void JavaParser::booleanLiteral()
    {
   m_gJavaExpr->booleanLiteral( );
	}

    void JavaParser::switchBlockStatementGroup()
    {
   m_gJavaStat->switchBlockStatementGroup( );
	}

    void JavaParser::annotationTypeElementRest()
    {
   m_gJavaAnnotations->annotationTypeElementRest( );
	}

    void JavaParser::formalParameterDecls()
    {
   m_gJavaDecl->formalParameterDecls( );
	}

    void JavaParser::constantExpression()
    {
   m_gJavaExpr->constantExpression( );
	}

    void JavaParser::selector()
    {
   m_gJavaExpr->selector( );
	}

    void JavaParser::classDeclaration()
    {
   m_gJavaDecl->classDeclaration( );
	}

    void JavaParser::packageOrTypeName()
    {
   m_gJavaDecl->packageOrTypeName( );
	}

    void JavaParser::enumBodyDeclarations()
    {
   m_gJavaDecl->enumBodyDeclarations( );
	}

    void JavaParser::variableDeclaratorId()
    {
   m_gJavaDecl->variableDeclaratorId( );
	}

    void JavaParser::methodDeclaratorRest()
    {
   m_gJavaDecl->methodDeclaratorRest( );
	}

    void JavaParser::explicitGenericInvocationSuffix()
    {
   m_gJavaExpr->explicitGenericInvocationSuffix( );
	}

    void JavaParser::annotationTypeDeclaration()
    {
   m_gJavaAnnotations->annotationTypeDeclaration( );
	}

    void JavaParser::expression()
    {
   m_gJavaExpr->expression( );
	}

    void JavaParser::andExpression()
    {
   m_gJavaExpr->andExpression( );
	}

    void JavaParser::assignmentOperator()
    {
   m_gJavaExpr->assignmentOperator( );
	}

    void JavaParser::integerLiteral()
    {
   m_gJavaExpr->integerLiteral( );
	}

/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool JavaParser::msynpred( antlr3::ClassForwarder< synpred1_Java >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_Java_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
